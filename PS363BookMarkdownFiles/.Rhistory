#' @rdname EAP
#' @aliases EAP,ANY-method
#' @export
setGeneric(name="EAP",
def=function(raschObj, lower, upper, ...)
{standardGeneric("EAP")}
)
##Setting generic EAP
#' @export
setMethod("EAP",
def=function(raschObj, lower = -6, upper = 6, ...){
##EAP returns the integral on the curve representing the prodcut of the
#outcomes of the Likelihood fuction and the
#prior funtion for a given theta value
##It takes as input an object of class Rasch and lower and upper bounds to the integral
#The defauts bounds are -6 and 6
##It returns as an output the theta hat value calculated by integration
product <- function(theta, raschObj){
##product returns the product of the outcomes of the Likelihood fuction and the
#prior funtion for a given theta value
sapply(theta, function(theta) Likelihood(raschObj, theta)*(Prior(theta)), simplify = T)
}
aPosteriori <- integrate(product, lower, upper, raschObj)
return(aPosteriori)
}
)
EAP(Rasch1, -6, 6)
library(devtools)
library(roxygen2)
setwd("~/Desktop/Midterm")
package.skeleton('easyRasch')
current.code <- as.package("easyRasch")
load_all(current.code)
document(current.code)
current.code <- as.package("easyRasch")
current.code <- as.package("easyRasch")
load_all(current.code)
current.code <- as.package("easyRasch")
load_all(current.code)
document(current.code)
library(devtools)
library(roxygen2)
setwd("~/Desktop/Midterm")
current.code <- as.package("easyRasch")
load_all(current.code)
document(current.code)
library(easyRasch)
library(devtools)
library(roxygen2)
current.code <- as.package("easyRasch")
load_all(current.code)
document(current.code)
example(Probability)
difficulty <- sample((-3:3), 5, replace=T)
#' answers <- sample(c(1,0), 5, replace =T)
#' demoRasch <- new("Rasch", name = "Alice", a = difficulty, y = answers)
#' ability <- 1
#' Probability(demoRasch, ability)
difficulty <- sample((-3:3), 5, replace=T)
answers <- sample(c(1,0), 5, replace =T)
demoRasch <- new("Rasch", name = "Alice", a = difficulty, y = answers)
ability <- 1
Probability(demoRasch, ability)
difficulty <- sample((-3:3), 5, replace=T)
answers <- sample(c(1,0), 5, replace =T)
demoRasch <- new("Rasch", name = "Alice", a = difficulty, y = answers)
ability <- 1
Probability(demoRasch, ability)
difficulty <- sample((-3:3), 5, replace=T)
answers <- sample(c(1,0), 5, replace =T)
demoRasch <- new("Rasch", name = "Alice", a = difficulty, y = answers)
lower <- -6
upper <- 6
EAP(demoRasch, lower,upper)
difficulty <- sample((-3:3), 5, replace=T)
answers <- sample(c(1,0), 5, replace =T)
demoRasch <- new("Rasch", name = "Alice", a = difficulty, y = answers)
raschPlot(Rasch1, T, 3)
raschPlot(demoRasch, T, 3)
etMethod('raschPlot',
def=function(raschObj, theta_hat = T, question,...){
##raschPlot plots the response function for a student for each question
##Tt takes as an input an object of class Rasch, the objerved theta hat, and the quetion on the exam
##It returns a graph of the respnse function
pValues <- sapply(-3:3, function(x) ((exp(x - raschObj@a))/(1+(exp(x - raschObj@a))))[[question]])
plotting <- function(raschObj, theta_hat = T, question){
##plotting is the function where the action graphing of the response function takes place
plot(seq(-3, 3), pValues,
xlim = c(-3,3),
##The c lim is -3 to 3
ylim = c(0,2),
xlab = 'Theta Values',
ylab = 'Probability Values',
main = paste0(raschObj@name, paste("'s Response Function for question", 1)),
type='o',
yaxt='n')
par(new=T)
hat <- EAP(RaschObj, -3, 3)$value
if(theta_hat == T){
##The option for the theta hat value
plot(hat, ((exp(hat - raschObj@a[question]))/(1+(exp(hat - raschObj@a[question])))),
xlim = c(-3,3),
ylim = c(0,2),
xlab = '',
ylab = '',
main = '',
col='blue',
type='o',
yaxt = 'n')
}
tic <- c(0, 0.5, 1)
axis(side = 2, tic, labels = T)
legend('topleft', legend = c('Response Function',"Theta Hat"), lty=c(1,1), col=c("black", "blue"))
##Adding a legend and adjusting tic marks
}
return(plotting(raschObj, theta_hat, question))
}
)
#' @export
setMethod('raschPlot',
def=function(raschObj, theta_hat = T, question,...){
##raschPlot plots the response function for a student for each question
##Tt takes as an input an object of class Rasch, the objerved theta hat, and the quetion on the exam
##It returns a graph of the respnse function
pValues <- sapply(-3:3, function(x) ((exp(x - raschObj@a))/(1+(exp(x - raschObj@a))))[[question]])
plotting <- function(raschObj, theta_hat = T, question){
##plotting is the function where the action graphing of the response function takes place
plot(seq(-3, 3), pValues,
xlim = c(-3,3),
##The c lim is -3 to 3
ylim = c(0,2),
xlab = 'Theta Values',
ylab = 'Probability Values',
main = paste0(raschObj@name, paste("'s Response Function for question", 1)),
type='o',
yaxt='n')
par(new=T)
hat <- EAP(RaschObj, -3, 3)$value
if(theta_hat == T){
##The option for the theta hat value
plot(hat, ((exp(hat - raschObj@a[question]))/(1+(exp(hat - raschObj@a[question])))),
xlim = c(-3,3),
ylim = c(0,2),
xlab = '',
ylab = '',
main = '',
col='blue',
type='o',
yaxt = 'n')
}
tic <- c(0, 0.5, 1)
axis(side = 2, tic, labels = T)
legend('topleft', legend = c('Response Function',"Theta Hat"), lty=c(1,1), col=c("black", "blue"))
##Adding a legend and adjusting tic marks
}
return(plotting(raschObj, theta_hat, question))
}
)
raschPlot(demoRasch, T, 3)
current.code <- as.package("easyRasch")
load_all(current.code)
document(current.code)
difficulty <- sample((-3:3), 5, replace=T)
answers <- sample(c(1,0), 5, replace =T)
demoRasch <- new("Rasch", name = "Alice", a = difficulty, y = answers)
raschPlot(demoRasch, T, 3)
setMethod('raschPlot',
def=function(raschObj, theta_hat = T, question,...){
##raschPlot plots the response function for a student for each question
##Tt takes as an input an object of class Rasch, the objerved theta hat, and the quetion on the exam
##It returns a graph of the respnse function
pValues <- sapply(-3:3, function(x) ((exp(x - raschObj@a))/(1+(exp(x - raschObj@a))))[[question]])
plotting <- function(raschObj, theta_hat = T, question){
##plotting is the function where the action graphing of the response function takes place
plot(seq(-3, 3), pValues,
xlim = c(-3,3),
##The c lim is -3 to 3
ylim = c(0,2),
xlab = 'Theta Values',
ylab = 'Probability Values',
main = paste0(raschObj@name, paste("'s Response Function for question", 1)),
type='o',
yaxt='n')
par(new=T)
hat <- EAP(raschObj, -3, 3)$value
if(theta_hat == T){
##The option for the theta hat value
plot(hat, ((exp(hat - raschObj@a[question]))/(1+(exp(hat - raschObj@a[question])))),
xlim = c(-3,3),
ylim = c(0,2),
xlab = '',
ylab = '',
main = '',
col='blue',
type='o',
yaxt = 'n')
}
tic <- c(0, 0.5, 1)
axis(side = 2, tic, labels = T)
legend('topleft', legend = c('Response Function',"Theta Hat"), lty=c(1,1), col=c("black", "blue"))
##Adding a legend and adjusting tic marks
}
return(plotting(raschObj, theta_hat, question))
}
)
raschPlot(demoRasch, T, 3)
current.code <- as.package("easyRasch")
library(MASS)
dgp.func <- function(n, p, q=0){
D = as.numeric(sample(n) <= (n/2)) # Treat half of sample
#For Logit Errors
e <- runif(n, 0, 1) # Generate random uniform(0,1) errors
e <- e/(1-e) # Errors expressed as odds
e <- log(e)*3 # Log odds
X <- rnorm(n) # Draw X random standard normal
latentr <- p*X + q*X*D + p*D + e # Response propensity ~ X + D + X:D
R <- latentr # Store response propensity as R
R[latentr <  1] <- 0 # Recode score < 1 as response
R[latentr >= 1] <- 1 # Recode score >= 1 as non-response
y.star <- 1 + 1*D + .5*X + 1*(D*X) + rnorm(n) # Y ~ D*X
data.sim <- as.data.frame(cbind(X, D, y.star, R)) # Store in data frame
data.sim$Y <- data.sim$y.star # Store responses as Y
data.sim$Y[data.sim$R==1] <- NA # Recode non-response as NA
data.sim$R.tilde <- 1 - data.sim$R # Store R.tilde as indicator where 1 == response
return(data.sim)
}
### Proposition 1 ###
Proposition1 <- function(Data) {
# Calculate response propensity: p(R = 1 | D, X)
pWeights <- glm(R.tilde ~ D*X,
family = binomial(link = logit),
data = Data)$fitted
# Estimate ATE: Y ~ D*X | p(D,X)
Model <- lm(Y ~ D*X, weights = 1/pWeights, data = Data)
return(list(ATE = Model$coefficients[2],
weights = pWeights))
}
### Proposition 2 ###
Proposition2 <- function(Data) {
# Subset data s.t. Response == 1
RespondentData <- Data[Data$R.tilde == 1, ]
# Calculate treatment propensity: p(D = 1 | X, R = 1)
PiWeights <- glm(D ~ X,
family = binomial(link = logit),
data = RespondentData)$fitted
# Replace pi(X) with 1-pi(X) where D == 0
PiWeights[RespondentData$D == 0] <- 1 - PiWeights[RespondentData$D == 0]
# Estimate ATE: Y ~ D | pi(X)
Model <- lm(Y ~ D, weights = 1/PiWeights, data = RespondentData)
return(list(ATE = Model$coefficients[2],
weights = PiWeights))
}
### Proposition 3 ###
Proposition3 <- function(Data) {
# Calculate response propensity: p(R = 1 | D, X)
pWeights <- glm(R.tilde ~ D*X,
family = binomial(link = logit),
data = Data)$fitted.values
# Subset data s.t. Response == 1
RespondentData <- Data[Data$R.tilde == 1, ]
# Calculate treatment propensity: p(D = 1 | X, R = 1)
PiWeights <- glm(D ~ X,
family = binomial(link = logit),
data = RespondentData)$fitted.values
# Replace pi(X) with 1-pi(X) where D == 0
PiWeights[RespondentData$D == 0] <- 1 - PiWeights[RespondentData$D == 0]
# Product of weights
ProductWeights <- pWeights[Data$R.tilde == 1]*PiWeights
# Estimate ATE: Y ~ D | pi(X)
Model <- lm(Y ~ D*X , weights = 1/ProductWeights, data = RespondentData)
return(list(ATE = Model$coefficients[2],
weights = ProductWeights, pWeights = pWeights, PiWeights=PiWeights ))
}
### Simulations for Propositions 1-3 Using dgp.func ###
nsim1 <- 1000 # set number of simulations
out1 <- matrix(NA, nsim1, 6) # empty matrix for estimate comparisons
weights1<-matrix(NA, nsim1, 6)
p.sim1 <- 1
for(i in 1:nsim1){ # iterate over simulations
data.tmp1 <- dgp.func(1000, p.sim1) # simulate data
out1[i,1] <- lm(y.star ~ D + X , data=data.tmp1)$coef[2] # OLS estimate under no attrition
out1[i,2] <- lm(Y ~ D , data=data.tmp1)$coef[2] # naive OLS estimate/No controls
out1[i,3] <- lm(Y ~ D + X, data=data.tmp1)$coef[2] # naive OLS estimate/With controls
thisProp1<-Proposition1(data.tmp1)
thisProp2<-Proposition2(data.tmp1)
thisProp3<-Proposition3(data.tmp1)
out1[i,4] <- thisProp1$ATE # Prop. 1 IPW OLS
out1[i,5] <- thisProp2$ATE # Prop. 2 IPW OLS
out1[i,6] <- thisProp3$ATE # Prop. 3 IPW OLS
weights1[i,1]<-max(thisProp1$weights)
weights1[i,2]<-min(thisProp1$weights)
weights1[i,3]<-max(thisProp2$weights)
weights1[i,4]<-min(thisProp2$weights)
weights1[i,5]<-max(thisProp3$weights)
weights1[i,6]<-min(thisProp3$weights)
rm(list=c("data.tmp1", "thisProp1", "thisProp2", "thisProp3"))
}
##Calculate errors in point estimation for each simulation
ateErrors<-matrix(NA, nrow=nsim1, ncol=5)
for(i in 1:5){
ateErrors[,i]<-out1[, (i+1)]-out1[,1]
}
colnames(ateErrors)<-c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.")
summary(ateErrors)
head(weights1) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
Results1<-summary(ateErrors)
par(mfrow=c(2,1), mar=c(1,2,1,.1), mgp=c(1,0,0), tcl=0)
boxplot(ateErrors, ylab="Bias", main="No attrition induced imballance in X")
abline(h=0)
Results1
#############################################################################
### Simulations for Propositions 1-3 Using dgp.func creating imbalance in X
## across Treatment/Control among non-attritted ###
#############################################################################
nsim2 <- 1000 # set number of simulations
out2 <- matrix(NA, nsim2, 6) # empty matrix for estimate comparisons
weights2<-matrix(NA, nsim2, 6)
p.sim2 <- 1
for(i in 1:nsim2){ # iterate over simulations
data.tmp2 <- dgp.func(1000, p.sim2, q=4) # simulate data
out2[i,1] <- lm(y.star ~ D + X , data=data.tmp2)$coef[2] # OLS estimate under no attrition
out2[i,2] <- lm(Y ~ D , data=data.tmp2)$coef[2] # naive OLS estimate/No controls
out2[i,3] <- lm(Y ~ D + X, data=data.tmp2)$coef[2] # naive OLS estimate/With controls
thisProp1<-Proposition1(data.tmp2)
thisProp2<-Proposition2(data.tmp2)
thisProp3<-Proposition3(data.tmp2)
out2[i,4] <- thisProp1$ATE # Prop. 1 IPW OLS
out2[i,5] <- thisProp2$ATE # Prop. 2 IPW OLS
out2[i,6] <- thisProp3$ATE # Prop. 3 IPW OLS
weights2[i,1]<-max(thisProp1$weights)
weights2[i,2]<-min(thisProp1$weights)
weights2[i,3]<-max(thisProp2$weights)
weights2[i,4]<-min(thisProp2$weights)
weights2[i,5]<-max(thisProp3$weights)
weights2[i,6]<-min(thisProp3$weights)
rm(list=c("data.tmp2", "thisProp1", "thisProp2", "thisProp3"))
}
## Example
dataTemp2<-dgp.func(1000, p.sim2, q=4)
summary(lm(X~D, data=dataTemp2)) # Random assigment
summary(lm(X~D, data=dataTemp2[dataTemp2$R.tilde==1,])) # Loss of randomness/imballance of X in observed
summary(lm(y.star~D, data=dataTemp2)) #True ATE
summary(lm(y.star~D+X, data=dataTemp2[dataTemp2$R.tilde==1,])) #True ATE|R=1
summary(lm(Y~D, data=dataTemp2)[dataTemp2$R.tilde==1,]) # Gives wrong answer
summary(lm(Y~D+X, data=dataTemp2)) # Gives wrong answer for ATE, but correct for ATE|R=1
Proposition3(dataTemp2)$ATE # All fixed
Proposition1(dataTemp2)$ATE # But so did this one
Proposition2(dataTemp2)$ATE # Gives same wrong answer as abvoe
rm(dataTemp2)
##Calculate errors in point estimation for each simulation
ateErrors2<-matrix(NA, nrow=nsim2, ncol=5)
for(i in 1:5){
ateErrors2[,i]<-out2[, (i+1)]-out2[,1]
}
colnames(ateErrors2)<-c("Naive/NC", "Naive/C", "Prop 1.", "Prop 2.", "Prop 3.")
head(weights2) ## Shows minimum and maximum predicted probabilities
## Via assumption 4' and 5', should not be too close to 0 or 1
## You may need to remove simulations where this is violated
Results2<-summary(ateErrors2)
boxplot(ateErrors2, ylab="Bias", main="With attrition induced imballance in X")
abline(h=0)
Results2
install.packages("bookdown")
install.packages("bookdown")
output: bookdown::
library(bookdown)
?bookdown
?gitbook
![Quantiative methods skills?](Graphics/napoleon.jpg)
knit_with_parameters('~/Dropbox/MathCamp/MathCamp2017/02Notation-And-Algebra.Rmd')
unlink('Dropbox/MathCamp/MathCamp2017/02Notation-And-Algebra_cache', recursive = TRUE)
?text
knitr::opts_chunk$set(echo = TRUE)
plot(x=2, y=3, xlim=c(0, 4), ylim=c(0,4), pch=19, cex=3
, xlab="X-axis", ylab="Y-axis", col="darkred")
abline(h=c(0,1,2,3,4),v=c(0,1,2,3,4), lty=2, col="gray40")
text(x=2.2, y=3.2, labels="(2, 3)", cex=1)
plot(x=2, y=3, xlim=c(0, 4), ylim=c(0,4), pch=19, cex=3
, xlab="X-axis", ylab="Y-axis", col="darkred")
abline(h=c(0,1,2,3,4),v=c(0,1,2,3,4), lty=2, col="gray40")
text(x=2.2, y=3.2, labels="(2, 3)", cex=1)
plot(x=c(2,3), y=c(1, 5), xlim=c(2, 3), ylim=c(0,4), pch=19, cex=3
, xlab="X-axis", ylab="Y-axis", col="darkred")
abline(a=-7, b=4)
text(x=c(2.2, 3.2), y=c(1.2, 5.2), labels="(2, 1)", cex=1)
library(png)
library(jpeg)
knitr::include_graphics("escalators.png", auto_pdf = TRUE, dpi = NULL)
str(knitr::include_graphics("escalators.png", auto_pdf = TRUE, dpi = NULL))
a<-(knitr::include_graphics("escalators.png", auto_pdf = TRUE, dpi = NULL)
)
a
str(a)
knitr::include_graphics("escalators.png", auto_pdf = TRUE, dpi = NULL)
unlink('Dropbox/MathCamp/MathCamp2017/03Functions_cache', recursive = TRUE)
library(devtools)
install_github("erossiter/catSurv")
data(warps)
data(warp)
?data
data()
data(ChickWeight)
str(ChickWeights)
data(ChickWeights)
boxplot(weight~Diet)
boxplot(weight~Diet, data=ChickWeight)
ChickWeight$weight[ChickWeight$Diet==1]
meanDiet1<-mean(ChickWeight$weight[ChickWeight$Diet==1])
text(1,meanDiet1, "Mean")
data(ChickWeights)
boxplot(weight~Diet, data=ChickWeight)
meanDiet1<-mean(ChickWeight$weight[ChickWeight$Diet==1])
text(1,meanDiet1, "Mean")
points(1,meanDiet1, col="red", pch=19)
?text
text(1,meanDiet1, "Mean", pos=1)
text(1,meanDiet1, "Mean", pos=2)
data(ChickWeights)
boxplot(weight~Diet, data=ChickWeight)
meanDiet1<-mean(ChickWeight$weight[ChickWeight$Diet==1])
text(1,meanDiet1, "Mean", pos=2)
points(1,meanDiet1, col="red", pch=19)
(63-78)/11
(65-78)/11
(67-78)/11
(63-78)/11
(67-78)/11
pnorm((63-78)/11)
pnorm((63-78)/11, lower.tail=FALSE)
pnorm(63)
pnorm(-1)
pnorm(-1, lower.tail=FALSE)
install.packages("swirl")
library("swirl")
install_course_github("jmontgomery", "QPMSwirl")
swirl()
library("swirl")
install_course_github("jmontgomery", "QPMSwirl")
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
bye()
library("swirl")
install_course_github("jmontgomery", "QPMSwirl")
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
bye()
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
bye()
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
bye()
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
-1
uninstall_all_courses(force = FALSE)
by()
bye()
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
bye()
uninstall_all_courses(force = FALSE)
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
bye()
install_course_github("jmontgomery", "QPMSwirl")
swirl()
-1
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
-1
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
-1
library("swirl")
uninstall_all_courses(force = FALSE)
install_course_github("jmontgomery", "QPMSwirl")
swirl()
-1
library("bookdown")
setwd("~/Documents/jmontgomery.github.io/PS363BookMarkdownFiles")
setwd("~/Github/jmontgomery.github.io/PS363BookMarkdownFiles")
bookdown::render_book(input="index.Rmd", output_dir="~/Documents/jmontgomery.github.io/PS363Coursebook")
setwd("~/Github/jmontgomery.github.io/PS363BookMarkdownFiles")
bookdown::render_book(input="index.Rmd", output_dir="~/Github/jmontgomery.github.io/PS363Coursebook")
knitr::opts_chunk$set(echo = TRUE)
x<-seq(0, 1, by=.001)
y<-dbeta( shape1 = 20+1,
shape2 = 100-20+1)
x<-seq(0, 1, by=.001)
y<-dbeta(x, shape1 = 20+1,
shape2 = 100-20+1)
plot(x, y, type="l")
fig.align="center", echo=TRUE}
x<-seq(0, .5, by=.001)
y<-dbeta(x, shape1 = 20+1,
shape2 = 100-20+1)
plot(x, y, type="l")
install.packages("HDInterval")
