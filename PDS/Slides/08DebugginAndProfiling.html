<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Debugging and Profiling</title>
    <meta charset="utf-8" />
    <meta name="date" content="2020-01-01" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Debugging and Profiling
### <div class="line-block">Jacob M. Montgomery<br />
<em>Washington University in St.Â Louis</em><br />
<em>Department of Politcal Science</em></div>
### 2020

---



## Orientation for today

**Last time**

1. Version control/documentation
    + Getting up on github
    + Helping your future self

&lt;br&gt;



--

**Today**

1. Debugging
2. Profiling

&lt;br&gt;

--

**Next class**
1. `ggplot`



---


# Basic debugging: browser(), debug(), traceback()


- `traceback` will help you identify the function that is failing
- `debug`, `debugonce` will go through a function one line at a time
- `browser` This let's you work within the function environment starting at a specified point

---


## Running example



```r
webData&lt;-url("http://pages.wustl.edu/montgomery/incumbents2.txt")
OOS &lt;- read.table(webData)
summary(OOS)
```

```
##        x             year         congress        chalspend     
##  Min.   :   1   Min.   :1956   Min.   : 84.00   Min.   : 8.517  
##  1st Qu.:1672   1st Qu.:1968   1st Qu.: 90.00   1st Qu.: 9.315  
##  Median :3347   Median :1978   Median : 95.00   Median :10.998  
##  Mean   :3348   Mean   :1977   Mean   : 94.42   Mean   :10.880  
##  3rd Qu.:5024   3rd Qu.:1988   3rd Qu.:100.00   3rd Qu.:12.366  
##  Max.   :6695   Max.   :1996   Max.   :104.00   Max.   :15.039  
##                                                 NA's   :3380    
##     incspend         difflog          presvote         voteshare     
##  Min.   : 8.586   Min.   :-3.060   Min.   :0.06565   Min.   :0.3476  
##  1st Qu.:12.304   1st Qu.: 0.686   1st Qu.:0.46894   1st Qu.:0.5740  
##  Median :12.839   Median : 1.651   Median :0.55519   Median :0.6450  
##  Mean   :12.759   Mean   : 1.858   Mean   :0.55335   Mean   :0.6470  
##  3rd Qu.:13.266   3rd Qu.: 3.025   3rd Qu.:0.63425   3rd Qu.:0.7141  
##  Max.   :15.422   Max.   : 5.856   Max.   :0.96061   Max.   :0.9997  
##  NA's   :3374     NA's   :3436                       NA's   :125     
##     inparty          incparty       seniority         midterm      
##  Min.   :0.0000   Min.   :0.000   Min.   : 1.000   Min.   :0.0000  
##  1st Qu.:0.0000   1st Qu.:0.000   1st Qu.: 2.000   1st Qu.:0.0000  
##  Median :0.0000   Median :1.000   Median : 4.000   Median :0.0000  
##  Mean   :0.4942   Mean   :0.563   Mean   : 4.949   Mean   :0.2327  
##  3rd Qu.:1.0000   3rd Qu.:1.000   3rd Qu.: 7.000   3rd Qu.:0.0000  
##  Max.   :1.0000   Max.   :1.000   Max.   :26.000   Max.   :1.0000  
##                                                                    
##   chalquality         south          population        urban       
##  Min.   :0.0000   Min.   :0.0000   Min.   :11.98   Min.   : 5.956  
##  1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:12.92   1st Qu.:12.325  
##  Median :0.0000   Median :0.0000   Median :13.06   Median :12.728  
##  Mean   :0.2348   Mean   :0.2378   Mean   :13.04   Mean   :12.612  
##  3rd Qu.:0.0000   3rd Qu.:0.0000   3rd Qu.:13.16   3rd Qu.:13.006  
##  Max.   :1.0000   Max.   :1.0000   Max.   :17.08   Max.   :16.481  
##  NA's   :5                         NA's   :2       NA's   :2       
##      age65            milpop         unemployed       incspend2      
##  Min.   : 8.164   Min.   : 3.045   Min.   : 7.425   Min.   :   5355  
##  1st Qu.:10.452   1st Qu.: 5.517   1st Qu.: 8.816   1st Qu.: 220620  
##  Median :10.760   Median : 6.246   Median : 9.142   Median : 376741  
##  Mean   :10.819   Mean   : 6.777   Mean   : 9.170   Mean   : 450124  
##  3rd Qu.:11.215   3rd Qu.: 8.077   3rd Qu.: 9.544   3rd Qu.: 577283  
##  Max.   :14.552   Max.   :12.691   Max.   :13.147   Max.   :4987593  
##  NA's   :2        NA's   :2        NA's   :2        NA's   :3374
```


---


```r
boxplot(voteshare~inparty, data=OOS[OOS$year==1956,])
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---


```r
plot(voteshare~inparty, data=OOS[OOS$year==1956,])
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---

## Running a regression by year: Do you see a pattern?



```r
output.vector&lt;-NULL
for (i in unique(OOS$year)){
    output.vector[which(unique(OOS$year) == i)]&lt;- 
      lm(voteshare ~ inparty, data=OOS[OOS$year == i,])$coefficients[2]
}
plot(unique(OOS$year), output.vector, type="l", ylab="Coefficient (Presiden'ts party)", xlab="Year") 
abline(h=0, lty=3)
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;



---

## Functionalize it


- Now we might think -- there is a more general case where I want to get a bunch of seperate regression estimates on defined subsets of the data

```r
by.var.lm&lt;-function(by.var, formula, data, coef.num){
  output.vector&lt;-NULL
  for (i in unique(by.var)){
    output.vector[which(unique(by.var) == i)]&lt;- 
      lm(formula, data=data[by.var == i,])$coefficients[coef.num]
  }
  return(output.vector)
}
plot(by.var.lm(year, voteshare~inparty, OOS, 2), type="l")
```


---

## This is not working, what to do?

- As a first step, figure out where it's broken using `traceback`

```r
traceback(by.var.lm(year, voteshare~inparty, OOS, 2))
```



---

- A second thing to try is to use `debug`

```r
debug(by.var.lm)
```


---

- A second thing to try is to put a `broswer` function into the function itself

```r
browser()
```

---

- Another thing to try is just put in some various print commands



```r
by.var.lm&lt;-function(by.var, formula, data, coef.num){
  output.vector&lt;-NULL; print("one")
  for (i in unique(by.var)){ 
    print(i) # I can see where I get to in the loop
    output.vector[which(unique(by.var) == i)]&lt;- 
      lm(formula, data=data[by.var == i,])$coefficients[coef.num]
  }
  print('got out of loop')
  return(output.vector)
}
plot(by.var.lm(year, voteshare~inparty, OOS, 2), type="l")
```


---


## Class activity, debug the function and add comments

Do it

--- 


## So now I have a function that works, can I use it again?



```r
#Note for jacob: Need to ener in missing data into the 'Class' variable.

website&lt;-url("http://pages.wustl.edu/montgomery/titanic")
titanic&lt;-read.delim(website)
table(titanic$Gender)
table(titanic$Class)
```


---

## Make this work



```r
by.var.lm(Class, (as.numeric(Survived)-1) ~ Gender, titanic, 2)
```


---


# Benchmarking and code improvements


```r
x &lt;- runif(500)
system.time(sqrt(x))
```

```
##    user  system elapsed 
##       0       0       0
```


The goal is to see how long a function takes to evaluate

---


## Much better: microbenchmark



```r
library(microbenchmark)
microbenchmark(sqrt(x)) # evalues 100 times per default
```

```
## Unit: microseconds
##     expr min    lq    mean median    uq  max neval
##  sqrt(x) 3.1 3.301 3.76192 3.5005 3.801 12.2   100
```

```r
microbenchmark(sqrt(x), times=1000)
```

```
## Unit: microseconds
##     expr min    lq     mean median     uq   max neval
##  sqrt(x)   3 3.301 6.216595  5.701 7.4005 177.2  1000
```

---

## Now we can compare different functions


```r
microbenchmark(sqrt(x), 
               x^0.5,
               times=1000)
```

```
## Unit: microseconds
##     expr    min     lq     mean median      uq     max neval
##  sqrt(x)  2.801  3.301  5.75679  5.301  6.5010  99.802  1000
##    x^0.5 21.301 23.601 31.21360 29.201 37.4005 155.501  1000
```



```r
microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2),
               times=1000)
```

```
## Unit: microseconds
##           expr    min      lq      mean  median      uq     max neval
##        sqrt(x)  2.900  3.2020  5.348097  4.3010  6.4010  61.501  1000
##          x^0.5 21.301 23.1020 30.287503 25.1010 35.6015 519.901  1000
##        x^(1/2) 21.701 23.4010 30.972693 25.4010 36.0010 573.101  1000
##  exp(log(x)/2) 52.001 55.0505 63.365686 57.9005 68.0510 293.702  1000
```


---

## And also completely different functions

```r
microbenchmark(sqrt(x), x^4-3*x)
```

```
## Unit: microseconds
##         expr    min      lq     mean median     uq    max neval
##      sqrt(x)  3.101  5.7020  6.06300  6.000  6.401 13.602   100
##  x^4 - 3 * x 30.301 47.4005 49.53791 52.201 54.401 58.800   100
```

---

- For ease of interpretation, if a microbenchmark takes
- 1 millisecond, then 1,000 calls take a second
- 1 microsecond, then 1,000,000 calls take a second
- 1 nanosecond,  then 1,000,000,000 calls take a second
- Or use unit=eps for evaluations per second


```r
microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2),
               unit="eps")
```

```
## Unit: evaluations per second
##           expr       min       lq      mean    median        uq       max neval
##        sqrt(x) 31946.840 85831.06 129148.91 139857.06 163894.13 294117.65   100
##          x^0.5  8703.144 25939.37  27305.16  26989.87  28901.14  40814.66   100
##        x^(1/2)  6830.508 25607.58  27030.14  26737.80  28208.01  40322.58   100
##  exp(log(x)/2)  6184.254 13764.35  14119.33  14244.74  14641.18  17270.86   100
```


---

- Evaluating every function takes time
- Evaluating () or {} takes time
- Even specifying useless arguments in functions takes time!


```r
f0 &lt;- function() NULL
f1 &lt;- function(a=1) NULL
f2 &lt;- function(a=1, b=2) NULL
f3 &lt;- function(a=1, b=2, c=3) NULL
f4 &lt;- function(a=1, b=2, c=3, d=4) NULL
f5 &lt;- function(a=1, b=2, c=3, d=4, e=5) NULL
```


---


```r
microbenchmark(f0(), f1(), f2(), f3(), f4(), f5(), times=10000)
```

```
## Unit: nanoseconds
##  expr min  lq     mean median  uq     max neval
##  f0() 100 201 395.3887    201 301  847601 10000
##  f1() 100 201 372.3049    201 302  488501 10000
##  f2() 100 201 528.1835    202 401 1646001 10000
##  f3() 200 201 499.5278    301 402  728201 10000
##  f4() 200 301 608.6536    301 501 1359801 10000
##  f5() 200 301 667.4762    400 600 1273300 10000
```


---

## There is room for improvement (or mistakes) in the most basic functions!
## Extracting one element of a data frame


```r
?mtcars
```

```
## starting httpd help server ... done
```

```r
head(mtcars)
```

```
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
```


---



```r
microbenchmark(
  "[32, 11]" = mtcars[32,11],
  "$carb[32]"	= mtcars$carb[32],
  "[[c(11, 32)]]" = mtcars[[c(11,32)]],
  "[[11]][32]" = mtcars[[11]][32],
  ".subset2" = .subset2(mtcars,11)[32])
```

```
## Unit: nanoseconds
##           expr   min      lq     mean  median      uq    max neval
##       [32, 11] 19000 21351.5 53927.02 29200.5 41251.0 704501   100
##      $carb[32]  2100  2901.5  5325.93  3901.0  5350.5  67601   100
##  [[c(11, 32)]]  8300 10601.5 19999.94 12651.0 16751.0 327601   100
##     [[11]][32]  7701  9901.0 13470.00 11551.0 14801.0  51402   100
##       .subset2   400   601.0  1210.05   751.5  1051.0  12101   100
```

---


# Vectorizing

- The key idea behind vectorizing your code is to think about entire
- vectors instead of thinking about their components. Using apply and co
- instead of for loops is a start, but does not really solve this issue.
- Truly vectorized functions will make use of code written in C instead 
 of R. Loops in C are much faster because they have much less overhead.

---

## Addition on each element of a data frame


```r
rm(list=ls())
m=5
n=5
matrix1 &lt;- replicate(m, rnorm(n)) # create matrix
matdf &lt;- matdf1 &lt;- data.frame(matrix1) 
matdf
```

```
##             X1         X2         X3         X4         X5
## 1  2.346610869 -2.6101532  1.7526321  1.3310011  1.6594958
## 2 -0.006627575  0.5405199 -1.2357960  2.3963154  0.4837881
## 3 -0.223863437 -0.9317292  0.7231342 -0.7493761 -1.8612009
## 4 -0.824166123  1.2611699 -0.5047348 -1.2154637  0.5686489
## 5 -0.956151794  1.0389304  0.4393905 -1.4025333 -0.8730912
```

---
  
  



```r
for (i in 1:m) {
  for (j in 1:n) {
    matdf1[i,j] &lt;- matdf1[i,j] + 1.87*cos(.25)*pi # addition
  }
}
matdf1
```

```
##         X1       X2       X3       X4       X5
## 1 8.038757 3.081992 7.444778 7.023147 7.351641
## 2 5.685518 6.232666 4.456350 8.088461 6.175934
## 3 5.468282 4.760416 6.415280 4.942769 3.830945
## 4 4.867980 6.953316 5.187411 4.476682 6.260795
## 5 4.735994 6.731076 6.131536 4.289612 4.819054
```

---


```r
matdf2&lt;-data.frame(matrix1) 
matdf2 &lt;- matdf2 + 1.87*cos(.25)*pi
matdf2
```

```
##         X1       X2       X3       X4       X5
## 1 8.038757 3.081992 7.444778 7.023147 7.351641
## 2 5.685518 6.232666 4.456350 8.088461 6.175934
## 3 5.468282 4.760416 6.415280 4.942769 3.830945
## 4 4.867980 6.953316 5.187411 4.476682 6.260795
## 5 4.735994 6.731076 6.131536 4.289612 4.819054
```


---


```r
microbenchmark(
  "loop" = for (i in 1:m) {
    for (j in 1:n) {
      matdf[i,j] &lt;- matdf[i,j] + 1.87*cos(.25)*pi
    }
  }, 
  "vectorized" = matdf &lt;- matdf + 1.87*cos(.25)*pi
)
```

```
## Unit: microseconds
##        expr      min         lq      mean     median        uq       max neval
##        loop 9401.901 10827.7510 13377.502 12833.7510 15273.352 24501.901   100
##  vectorized  526.201   788.1005  1001.068   866.1515  1222.351  2726.601   100
```


---


```r
mat1 &lt;- matrix(abs(rnorm(2500))+pi, ncol=50)
apply(mat1, 1, function(x) sum(x))
```

```
##  [1] 195.3099 198.2855 202.1538 199.2565 199.2470 186.6250 196.3565 200.2620
##  [9] 190.3582 197.4863 191.2594 197.7650 196.1485 195.3302 191.6544 194.8142
## [17] 193.6832 201.0293 195.5628 199.8036 196.3346 196.5478 198.5907 195.6275
## [25] 191.4607 201.5842 200.8171 191.8131 194.7158 192.1614 200.5761 196.3138
## [33] 198.9787 195.7550 188.7367 195.4937 202.6743 194.7211 204.0799 191.6572
## [41] 193.9938 196.3509 193.7443 202.4763 197.6612 203.3329 200.5762 194.9349
## [49] 197.4016 197.6620
```

```r
rowSums(mat1)
```

```
##  [1] 195.3099 198.2855 202.1538 199.2565 199.2470 186.6250 196.3565 200.2620
##  [9] 190.3582 197.4863 191.2594 197.7650 196.1485 195.3302 191.6544 194.8142
## [17] 193.6832 201.0293 195.5628 199.8036 196.3346 196.5478 198.5907 195.6275
## [25] 191.4607 201.5842 200.8171 191.8131 194.7158 192.1614 200.5761 196.3138
## [33] 198.9787 195.7550 188.7367 195.4937 202.6743 194.7211 204.0799 191.6572
## [41] 193.9938 196.3509 193.7443 202.4763 197.6612 203.3329 200.5762 194.9349
## [49] 197.4016 197.6620
```

---



```r
microbenchmark(apply(mat1, 1, function(x) sum(x)),
               rowSums(mat1))
```

```
## Unit: microseconds
##                                expr     min       lq      mean   median      uq
##  apply(mat1, 1, function(x) sum(x)) 177.801 275.9505 444.01602 385.9505 452.701
##                       rowSums(mat1)  17.501  23.0515  36.91509  31.6515  40.501
##       max neval
##  3282.201   100
##   155.501   100
```


---

- Even for basic tasks, think about the actual calculations you perform


```r
mat2 &lt;- matrix(sample(1:7, 90000, replace=T), ncol=300)
mat3 &lt;- matrix(sample(2:6, 90000, replace=T), ncol=300)
ys &lt;- sample(3:5, 300, replace=T)
```


---


```r
all.equal(mat2 %*% mat3 %*% ys , mat2 %*% (mat3 %*% ys))
```

```
## [1] TRUE
```

```r
microbenchmark(mat2 %*% mat3 %*% ys,
               mat2 %*% (mat3 %*% ys))
```

```
## Unit: microseconds
##                    expr     min        lq      mean    median        uq     max
##    mat2 %*% mat3 %*% ys 17604.7 24222.852 27762.106 26755.351 30902.950 50398.6
##  mat2 %*% (mat3 %*% ys)   770.6  1440.101  2237.485  1658.401  1968.051 26537.7
##  neval
##    100
##    100
```

- Why?  Think through the dimensionality


---

## Paste/collapse and copies


```r
random_states &lt;- function() {
  paste(sample(state.name,10,replace =TRUE),collapse ="")
}
states10 &lt;- replicate(10, random_states())
states10
```

```
##  [1] "KentuckyNew MexicoArkansasHawaiiNorth DakotaAlabamaFloridaCaliforniaMinnesotaNevada"         
##  [2] "MissouriSouth DakotaTexasNorth CarolinaUtahNew YorkWest VirginiaIllinoisOregonSouth Carolina"
##  [3] "ConnecticutArizonaIowaOregonMaineLouisianaFloridaMichiganIowaHawaii"                         
##  [4] "MontanaArizonaOregonSouth DakotaNew MexicoWyomingNorth CarolinaRhode IslandHawaiiNew York"   
##  [5] "South CarolinaArkansasNevadaNew JerseyArkansasRhode IslandSouth DakotaTennesseeMaineVermont" 
##  [6] "IndianaNebraskaTexasWashingtonVermontIowaIndianaSouth CarolinaOhioNew Mexico"                
##  [7] "New MexicoOregonIllinoisMichiganKansasOhioIllinoisNew MexicoNew YorkVirginia"                
##  [8] "North CarolinaKansasIdahoArkansasNew JerseyIndianaVirginiaAlabamaTexasConnecticut"           
##  [9] "UtahGeorgiaOklahomaNorth DakotaNew YorkCaliforniaArkansasNebraskaAlabamaIndiana"             
## [10] "North DakotaNew YorkPennsylvaniaUtahNevadaMissouriArkansasVirginiaConnecticutAlabama"
```

```r
states100 &lt;- replicate(100, random_states())
```


---


```r
collapse &lt;- function(states) {
  out &lt;- ""
  for (x in states) {
    out &lt;- paste0(out, x) # same as paste(..., sep="", collapse)
  }
  out
}
```

---


```r
microbenchmark(
  "loop10" = collapse(states10),
  "vec10" = paste(states10, collapse =""),
  "loop100" = collapse(states100),
  "vec100" = paste(states100, collapse ="")
)
```

```
## Unit: microseconds
##     expr      min       lq       mean    median        uq      max neval
##   loop10   28.601   36.651   60.79801   54.5505   65.2010  326.301   100
##    vec10    8.300   13.301   18.86502   15.9010   20.9015  111.300   100
##  loop100 1504.201 1633.051 2224.62202 2235.5010 2428.9510 5476.401   100
##   vec100   75.601   96.601  142.11393  124.3010  145.7510  757.801   100
```

---

## Allocate memory and fill, don't append to the end

- Here, we are not only getting around using the loop, but also avoiding copies. 
- Whenever you append(), cbind(), rbind(), or paste() to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home. 
- If you're repeating this many times, like in a for loop, this can be quite computationally expensive.


---

### Class exercise

1. Make a new version of `by.var.lm`
2. Let's see which team can find the fastest implementation
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
