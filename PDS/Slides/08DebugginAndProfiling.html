<!DOCTYPE html>
<html>
  <head>
    <title>Debugging and Profiling</title>
    <meta charset="utf-8">
    <meta name="date" content="2020-01-01" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Debugging and Profiling
### <div style="white-space: pre-line;">Jacob M. Montgomery
<em>Washington University in St.Â Louis</em>
<em>Department of Politcal Science</em></div>
### 2020

---



## Orientation for today

**Last time**

1. Version control/documentation
    + Getting up on github
    + Helping your future self

&lt;br&gt;



--

**Today**

1. Debugging
2. Profiling

&lt;br&gt;

--

**Next class**
1. `ggplot`



---


# Basic debugging: browser(), debug(), traceback()


- `traceback` will help you identify the function that is failing
- `debug`, `debugonce` will go through a function one line at a time
- `browser` This let's you work within the function environment starting at a specified point

---


## Running example



```r
webData&lt;-url("http://pages.wustl.edu/montgomery/incumbents2.txt")
OOS &lt;- read.table(webData)
summary(OOS)
```

```
##        x             year         congress        chalspend     
##  Min.   :   1   Min.   :1956   Min.   : 84.00   Min.   : 8.517  
##  1st Qu.:1672   1st Qu.:1968   1st Qu.: 90.00   1st Qu.: 9.315  
##  Median :3347   Median :1978   Median : 95.00   Median :10.998  
##  Mean   :3348   Mean   :1977   Mean   : 94.42   Mean   :10.880  
##  3rd Qu.:5024   3rd Qu.:1988   3rd Qu.:100.00   3rd Qu.:12.366  
##  Max.   :6695   Max.   :1996   Max.   :104.00   Max.   :15.039  
##                                                 NA's   :3380    
##     incspend         difflog          presvote         voteshare     
##  Min.   : 8.586   Min.   :-3.060   Min.   :0.06565   Min.   :0.3476  
##  1st Qu.:12.304   1st Qu.: 0.686   1st Qu.:0.46894   1st Qu.:0.5740  
##  Median :12.839   Median : 1.651   Median :0.55519   Median :0.6450  
##  Mean   :12.759   Mean   : 1.858   Mean   :0.55335   Mean   :0.6470  
##  3rd Qu.:13.266   3rd Qu.: 3.025   3rd Qu.:0.63425   3rd Qu.:0.7141  
##  Max.   :15.422   Max.   : 5.856   Max.   :0.96061   Max.   :0.9997  
##  NA's   :3374     NA's   :3436                       NA's   :125     
##     inparty          incparty       seniority         midterm      
##  Min.   :0.0000   Min.   :0.000   Min.   : 1.000   Min.   :0.0000  
##  1st Qu.:0.0000   1st Qu.:0.000   1st Qu.: 2.000   1st Qu.:0.0000  
##  Median :0.0000   Median :1.000   Median : 4.000   Median :0.0000  
##  Mean   :0.4942   Mean   :0.563   Mean   : 4.949   Mean   :0.2327  
##  3rd Qu.:1.0000   3rd Qu.:1.000   3rd Qu.: 7.000   3rd Qu.:0.0000  
##  Max.   :1.0000   Max.   :1.000   Max.   :26.000   Max.   :1.0000  
##                                                                    
##   chalquality         south          population        urban       
##  Min.   :0.0000   Min.   :0.0000   Min.   :11.98   Min.   : 5.956  
##  1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:12.92   1st Qu.:12.325  
##  Median :0.0000   Median :0.0000   Median :13.06   Median :12.728  
##  Mean   :0.2348   Mean   :0.2378   Mean   :13.04   Mean   :12.612  
##  3rd Qu.:0.0000   3rd Qu.:0.0000   3rd Qu.:13.16   3rd Qu.:13.006  
##  Max.   :1.0000   Max.   :1.0000   Max.   :17.08   Max.   :16.481  
##  NA's   :5                         NA's   :2       NA's   :2       
##      age65            milpop         unemployed       incspend2      
##  Min.   : 8.164   Min.   : 3.045   Min.   : 7.425   Min.   :   5355  
##  1st Qu.:10.452   1st Qu.: 5.517   1st Qu.: 8.816   1st Qu.: 220620  
##  Median :10.760   Median : 6.246   Median : 9.142   Median : 376741  
##  Mean   :10.819   Mean   : 6.777   Mean   : 9.170   Mean   : 450124  
##  3rd Qu.:11.215   3rd Qu.: 8.077   3rd Qu.: 9.544   3rd Qu.: 577283  
##  Max.   :14.552   Max.   :12.691   Max.   :13.147   Max.   :4987593  
##  NA's   :2        NA's   :2        NA's   :2        NA's   :3374
```


---


```r
boxplot(voteshare~inparty, data=OOS[OOS$year==1956,])
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---


```r
plot(voteshare~inparty, data=OOS[OOS$year==1956,])
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---

## Running a regression by year: Do you see a pattern?



```r
output.vector&lt;-NULL
for (i in unique(OOS$year)){
    output.vector[which(unique(OOS$year) == i)]&lt;- 
      lm(voteshare ~ inparty, data=OOS[OOS$year == i,])$coefficients[2]
}
plot(unique(OOS$year), output.vector, type="l", ylab="Coefficient (Presiden'ts party)", xlab="Year") 
abline(h=0, lty=3)
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;



---

## Functionalize it


- Now we might think -- there is a more general case where I want to get a bunch of seperate regression estimates on defined subsets of the dat

```r
by.var.lm&lt;-function(by.var, formula, data, coef.num){
  output.vector&lt;-NULL
  for (i in unique(by.var)){
    output.vector[which(unique(by.var) == i)]&lt;- 
      lm(formula, data=data[by.var == i,])$coefficients[coef.num]
  }
  return(output.vector)
}
plot(by.var.lm(year, voteshare~inparty, OOS, 2), type="l")
```


---

## This is not working, what to do?

- As a first step, figure out where it's broken using `traceback`

```r
traceback(by.var.lm)
```



---

- A second thing to try is to use `debug`

```r
debug(by.var.lm)
```


---

- A second thing to try is to put a `broswer` function into the function itself

```r
browser(by.var.lm)
```

---

- Another thing to try is just put in some various print commands



```r
by.var.lm&lt;-function(by.var, formula, data, coef.num){
  output.vector&lt;-NULL; print("one")
  for (i in unique(by.var)){ 
    print(i) # I can see where I get to in the loop
    output.vector[which(unique(by.var) == i)]&lt;- 
      lm(formula, data=data[by.var == i,])$coefficients[coef.num]
  }
  print('got out of loop')
  return(output.vector)
}
plot(by.var.lm(year, voteshare~inparty, OOS, 2), type="l")
```


---


## Class activity, debug the function and add comments

Do it

--- 


## So now I have a function that works, can I use it again?



```r
website&lt;-url("http://pages.wustl.edu/montgomery/titanic")
titanic&lt;-read.delim(website)
table(titanic$Gender)
table(titanic$Class)
```


---

## Make this work



```r
by.var.lm(Class, (as.numeric(Survived)-1) ~ Gender, titanic, 2)
```


---


# Benchmarking and code improvements


```r
x &lt;- runif(500)
system.time(sqrt(x))
```

```
##    user  system elapsed 
##       0       0       0
```


The goal is to see how long a function takes to evaluate

---


## Much better: microbenchmark



```r
library(microbenchmark)
microbenchmark(sqrt(x)) # evalues 100 times per default
```

```
## Unit: microseconds
##     expr   min     lq    mean median    uq   max neval
##  sqrt(x) 1.368 1.3815 1.51211 1.3965 1.474 7.649   100
```

```r
microbenchmark(sqrt(x), times=1000)
```

```
## Unit: microseconds
##     expr   min    lq     mean median    uq   max neval
##  sqrt(x) 1.353 1.384 1.434195  1.393 1.454 3.308  1000
```

---

## Now we can compare different functions


```r
microbenchmark(sqrt(x), 
               x^0.5,
               times=1000)
```

```
## Unit: microseconds
##     expr    min      lq      mean median      uq    max neval cld
##  sqrt(x)  1.370  1.6060  1.775845  1.659  1.6810 30.333  1000  a 
##    x^0.5 12.807 13.4635 13.793035 13.515 13.5835 33.183  1000   b
```



```r
microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2),
               times=1000)
```

```
## Unit: microseconds
##           expr    min      lq      mean  median     uq    max neval cld
##        sqrt(x)  1.150  1.2930  1.850456  1.4275  1.686 18.856  1000 a  
##          x^0.5 11.005 11.6965 13.084599 12.7000 13.567 78.481  1000   c
##        x^(1/2) 11.133 11.8220 13.100480 12.9890 13.689 30.434  1000   c
##  exp(log(x)/2)  7.027  7.4975  8.579023  8.2980  8.812 25.100  1000  b
```


---

## And also completely different functions

```r
microbenchmark(sqrt(x), x^4-3*x)
```

```
## Unit: microseconds
##         expr    min      lq     mean  median      uq   max neval cld
##      sqrt(x)  1.373  1.4045  1.55133  1.4735  1.5835  5.22   100  a 
##  x^4 - 3 * x 14.150 14.2790 14.55651 14.4155 14.6395 20.01   100   b
```

---

- For ease of interpretation, if a microbenchmark takes
- 1 millisecond, then 1,000 calls take a second
- 1 microsecond, then 1,000,000 calls take a second
- 1 nanosecond,  then 1,000,000,000 calls take a second
- Or use unit=eps for evaluations per second


```r
microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2),
               unit="eps")
```

```
## Unit: evaluations per second
##           expr       min        lq      mean    median        uq       max
##        sqrt(x) 526038.93 627746.39 653559.76 664451.83 686577.49 703234.88
##          x^0.5  64094.35  73637.71  73722.91  74068.59  74263.86  74604.60
##        x^(1/2)  70501.97  72526.84  73008.68  73203.76  73542.93  73811.63
##  exp(log(x)/2)  69122.83 114830.34 114932.01 115801.05 116516.17 117412.23
##  neval cld
##    100   c
##    100 a  
##    100 a  
##    100  b
```


---

- Evaluating every function takes time
- Evaluating () or {} takes time
- Even specifying useless arguments in functions takes time!


```r
f0 &lt;- function() NULL
f1 &lt;- function(a=1) NULL
f2 &lt;- function(a=1, b=2) NULL
f3 &lt;- function(a=1, b=2, c=3) NULL
f4 &lt;- function(a=1, b=2, c=3, d=4) NULL
f5 &lt;- function(a=1, b=2, c=3, d=4, e=5) NULL
```


---


```r
microbenchmark(f0(), f1(), f2(), f3(), f4(), f5(), times=10000)
```

```
## Unit: nanoseconds
##  expr min  lq     mean median  uq    max neval cld
##  f0() 113 139 180.5799    142 145 365242 10000   a
##  f1() 146 163 208.3070    166 170 386214 10000   a
##  f2() 155 182 233.1229    186 191 414023 10000   a
##  f3() 173 203 304.1174    208 214 875707 10000   a
##  f4() 186 214 277.1056    226 236 415126 10000   a
##  f5() 210 239 301.1472    248 257 429270 10000   a
```


---

## There is room for improvement (or mistakes) in the most basic functions!
## Extracting one element of a data frame


```r
?mtcars
head(mtcars)
```

```
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
```


---



```r
microbenchmark(
  "[32, 11]" = mtcars[32,11],
  "$carb[32]"	= mtcars$carb[32],
  "[[c(11, 32)]]" = mtcars[[c(11,32)]],
  "[[11]][32]" = mtcars[[11]][32],
  ".subset2" = .subset2(mtcars,11)[32])
```

```
## Unit: nanoseconds
##           expr  min     lq     mean median      uq   max neval  cld
##       [32, 11] 9381 9766.5 10260.71 9950.5 10158.0 33036   100    d
##      $carb[32] 4576 4902.5  5222.87 5102.5  5343.5 13619   100   c 
##  [[c(11, 32)]] 3966 4182.0  4667.74 4309.5  4542.0 34071   100  bc 
##     [[11]][32] 3789 4013.5  4174.73 4103.5  4307.0  5915   100  b  
##       .subset2  240  298.0   437.76  327.0   360.0 10791   100 a
```

---


# Vectorizing

- The key idea behind vectorizing your code is to think about entire
- vectors instead of thinking about their components. Using apply and co
- instead of for loops is a start, but does not really solve this issue.
- Truly vectorized functions will make use of code written in C instead 
 of R. Loops in C are much faster because they have much less overhead.

---

## Addition on each element of a data frame


```r
rm(list=ls())
m=5
n=5
matrix1 &lt;- replicate(m, rnorm(n)) # create matrix
matdf &lt;- matdf1 &lt;- data.frame(matrix1) 
matdf
```

```
##           X1          X2          X3         X4         X5
## 1  2.0849825 -0.09046986 -0.57216854  0.4581393 -0.8009530
## 2 -0.6275854  0.27860409  0.07577869  0.3104347 -1.3972298
## 3 -0.8192008 -0.07042670 -1.35146280 -0.1966347 -0.4226049
## 4 -0.2119655  0.05758887 -1.74326157 -0.5828796 -1.0608194
## 5  0.1023961  0.66176328 -0.58615373 -0.5468998  1.4209720
```

---
  
  



```r
for (i in 1:m) {
  for (j in 1:n) {
    matdf1[i,j] &lt;- matdf1[i,j] + 1.87*cos(.25)*pi # addition
  }
}
matdf1
```

```
##         X1       X2       X3       X4       X5
## 1 7.777128 5.601676 5.119977 6.150285 4.891193
## 2 5.064560 5.970750 5.767924 6.002580 4.294916
## 3 4.872945 5.621719 4.340683 5.495511 5.269541
## 4 5.480180 5.749735 3.948884 5.109266 4.631326
## 5 5.794542 6.353909 5.105992 5.145246 7.113118
```

---


```r
matdf2&lt;-data.frame(matrix1) 
matdf2 &lt;- matdf2 + 1.87*cos(.25)*pi
matdf2
```

```
##         X1       X2       X3       X4       X5
## 1 7.777128 5.601676 5.119977 6.150285 4.891193
## 2 5.064560 5.970750 5.767924 6.002580 4.294916
## 3 4.872945 5.621719 4.340683 5.495511 5.269541
## 4 5.480180 5.749735 3.948884 5.109266 4.631326
## 5 5.794542 6.353909 5.105992 5.145246 7.113118
```


---


```r
microbenchmark(
  "loop" = for (i in 1:m) {
    for (j in 1:n) {
      matdf[i,j] &lt;- matdf[i,j] + 1.87*cos(.25)*pi
    }
  }, 
  "vectorized" = matdf &lt;- matdf + 1.87*cos(.25)*pi
)
```

```
## Unit: microseconds
##        expr      min       lq      mean   median        uq      max neval
##        loop 2527.625 2698.135 3122.9212 2977.468 3348.3615 4879.809   100
##  vectorized  200.504  226.438  274.3322  246.026  274.6395 2002.015   100
##  cld
##    b
##   a
```


---


```r
mat1 &lt;- matrix(abs(rnorm(2500))+pi, ncol=50)
apply(mat1, 1, function(x) sum(x))
```

```
##  [1] 193.7591 192.1265 190.1473 203.7406 194.0580 196.0168 203.2838
##  [8] 196.9489 197.1697 192.4887 195.3876 193.9431 194.2456 199.6896
## [15] 198.2287 194.4360 198.5176 201.1584 198.6691 192.4295 200.8114
## [22] 194.3398 196.4922 197.9362 193.0319 199.0876 201.3948 199.8477
## [29] 202.4536 190.6390 200.5018 190.0966 199.1441 198.8781 193.5316
## [36] 204.0101 195.4579 199.4311 193.3775 195.8397 196.4960 195.3596
## [43] 195.5127 201.5130 191.4689 203.2796 199.5514 192.7076 197.7837
## [50] 198.0625
```

```r
rowSums(mat1)
```

```
##  [1] 193.7591 192.1265 190.1473 203.7406 194.0580 196.0168 203.2838
##  [8] 196.9489 197.1697 192.4887 195.3876 193.9431 194.2456 199.6896
## [15] 198.2287 194.4360 198.5176 201.1584 198.6691 192.4295 200.8114
## [22] 194.3398 196.4922 197.9362 193.0319 199.0876 201.3948 199.8477
## [29] 202.4536 190.6390 200.5018 190.0966 199.1441 198.8781 193.5316
## [36] 204.0101 195.4579 199.4311 193.3775 195.8397 196.4960 195.3596
## [43] 195.5127 201.5130 191.4689 203.2796 199.5514 192.7076 197.7837
## [50] 198.0625
```

---



```r
microbenchmark(apply(mat1, 1, function(x) sum(x)),
               rowSums(mat1))
```

```
## Unit: microseconds
##                                expr     min       lq      mean   median
##  apply(mat1, 1, function(x) sum(x)) 104.966 130.2235 140.18326 131.8310
##                       rowSums(mat1)   7.967   8.4540   9.67267   9.4395
##        uq      max neval cld
##  136.1825 1010.212   100   b
##   10.0610   16.609   100  a
```


---

- Even for basic tasks, think about the actual calculations you perform


```r
mat2 &lt;- matrix(sample(1:7, 90000, replace=T), ncol=300)
mat3 &lt;- matrix(sample(2:6, 90000, replace=T), ncol=300)
ys &lt;- sample(3:5, 300, replace=T)
```


---


```r
all.equal(mat2 %*% mat3 %*% ys , mat2 %*% (mat3 %*% ys))
```

```
## [1] TRUE
```

```r
microbenchmark(mat2 %*% mat3 %*% ys,
               mat2 %*% (mat3 %*% ys))
```

```
## Unit: microseconds
##                    expr       min        lq       mean    median
##    mat2 %*% mat3 %*% ys 12566.818 13300.772 13924.0567 13675.425
##  mat2 %*% (mat3 %*% ys)   269.339   692.965   747.8587   722.054
##          uq       max neval cld
##  14221.5795 19371.216   100   b
##    757.1525  3221.367   100  a
```

- Why?  Think through the dimensionality


---

## Paste/collapse and copies


```r
random_states &lt;- function() {
  paste(sample(state.name,10,replace =TRUE),collapse ="")
}
states10 &lt;- replicate(10, random_states())
states10
```

```
##  [1] "KentuckyHawaiiNew MexicoMarylandMichiganIllinoisMarylandSouth CarolinaNebraskaOregon"               
##  [2] "MinnesotaWest VirginiaIowaVirginiaNorth CarolinaNew YorkWyomingMassachusettsArkansasIdaho"          
##  [3] "TexasWisconsinConnecticutIndianaWashingtonNew HampshireSouth CarolinaMarylandNew MexicoRhode Island"
##  [4] "HawaiiMinnesotaNebraskaIndianaMississippiMontanaNorth CarolinaNorth DakotaAlaskaMassachusetts"      
##  [5] "MaineVermontAlaskaMississippiOklahomaArkansasMontanaOregonIdahoMinnesota"                           
##  [6] "KansasIowaVermontArkansasSouth CarolinaMississippiDelawareArkansasMontanaPennsylvania"              
##  [7] "New MexicoMinnesotaDelawareNorth DakotaCaliforniaSouth DakotaMissouriVirginiaHawaiiHawaii"          
##  [8] "West VirginiaMarylandAlabamaMinnesotaNebraskaIndianaKentuckyColoradoOhioMontana"                    
##  [9] "AlabamaDelawareSouth DakotaNew MexicoWest VirginiaDelawareWashingtonTennesseeRhode IslandIndiana"   
## [10] "OklahomaVirginiaOhioWashingtonCaliforniaNorth CarolinaPennsylvaniaWest VirginiaNebraskaGeorgia"
```

```r
states100 &lt;- replicate(100, random_states())
```


---


```r
collapse &lt;- function(states) {
  out &lt;- ""
  for (x in states) {
    out &lt;- paste0(out, x) # same as paste(..., sep="", collapse)
  }
  out
}
```

---


```r
microbenchmark(
  "loop10" = collapse(states10),
  "vec10" = paste(states10, collapse =""),
  "loop100" = collapse(states100),
  "vec100" = paste(states100, collapse ="")
)
```

```
## Unit: microseconds
##     expr     min       lq      mean   median       uq      max neval cld
##   loop10  15.082  16.2545  19.01961  19.2805  20.6745   28.742   100  a 
##    vec10   4.497   5.1110   6.01534   5.9165   6.7045    8.544   100  a 
##  loop100 636.540 648.9110 792.64745 757.8075 845.8540 3047.051   100   b
##   vec100  38.130  40.5350  48.40826  48.4060  52.8610   73.845   100  a
```

---

## Allocate memory and fill, don't append to the end

- Here, we are not only getting around using the loop, but also avoiding copies. 
- Whenever you append(), cbind(), rbind(), or paste() to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home. 
- If you're repeating this many times, like in a for loop, this can be quite computationally expensive.


---

### Class exercise

1. Make a new version of `by.var.lm`
2. Let's see which team can find the fastest implementation
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
