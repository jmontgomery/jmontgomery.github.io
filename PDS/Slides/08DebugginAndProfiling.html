<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Debugging and Profiling</title>
    <meta charset="utf-8" />
    <meta name="date" content="2020-01-01" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Debugging and Profiling
### <div class="line-block">Jacob M. Montgomery<br />
<em>Washington University in St.Â Louis</em><br />
<em>Department of Politcal Science</em></div>
### 2020

---



## Orientation for today

**Last time**

1. Version control/documentation
    + Getting up on github
    + Helping your future self

&lt;br&gt;



--

**Today**

1. Debugging
2. Profiling

&lt;br&gt;

--

**Next class**
1. `ggplot`



---


# Basic debugging: browser(), debug(), traceback()


- `traceback` will help you identify the function that is failing
- `debug`, `debugonce` will go through a function one line at a time
- `browser` This let's you work within the function environment starting at a specified point

---


## Running example



```r
webData&lt;-url("http://pages.wustl.edu/montgomery/incumbents2.txt")
OOS &lt;- read.table(webData)
summary(OOS)
```

```
##        x             year         congress        chalspend     
##  Min.   :   1   Min.   :1956   Min.   : 84.00   Min.   : 8.517  
##  1st Qu.:1672   1st Qu.:1968   1st Qu.: 90.00   1st Qu.: 9.315  
##  Median :3347   Median :1978   Median : 95.00   Median :10.998  
##  Mean   :3348   Mean   :1977   Mean   : 94.42   Mean   :10.880  
##  3rd Qu.:5024   3rd Qu.:1988   3rd Qu.:100.00   3rd Qu.:12.366  
##  Max.   :6695   Max.   :1996   Max.   :104.00   Max.   :15.039  
##                                                 NA's   :3380    
##     incspend         difflog          presvote         voteshare     
##  Min.   : 8.586   Min.   :-3.060   Min.   :0.06565   Min.   :0.3476  
##  1st Qu.:12.304   1st Qu.: 0.686   1st Qu.:0.46894   1st Qu.:0.5740  
##  Median :12.839   Median : 1.651   Median :0.55519   Median :0.6450  
##  Mean   :12.759   Mean   : 1.858   Mean   :0.55335   Mean   :0.6470  
##  3rd Qu.:13.266   3rd Qu.: 3.025   3rd Qu.:0.63425   3rd Qu.:0.7141  
##  Max.   :15.422   Max.   : 5.856   Max.   :0.96061   Max.   :0.9997  
##  NA's   :3374     NA's   :3436                       NA's   :125     
##     inparty          incparty       seniority         midterm      
##  Min.   :0.0000   Min.   :0.000   Min.   : 1.000   Min.   :0.0000  
##  1st Qu.:0.0000   1st Qu.:0.000   1st Qu.: 2.000   1st Qu.:0.0000  
##  Median :0.0000   Median :1.000   Median : 4.000   Median :0.0000  
##  Mean   :0.4942   Mean   :0.563   Mean   : 4.949   Mean   :0.2327  
##  3rd Qu.:1.0000   3rd Qu.:1.000   3rd Qu.: 7.000   3rd Qu.:0.0000  
##  Max.   :1.0000   Max.   :1.000   Max.   :26.000   Max.   :1.0000  
##                                                                    
##   chalquality         south          population        urban       
##  Min.   :0.0000   Min.   :0.0000   Min.   :11.98   Min.   : 5.956  
##  1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:12.92   1st Qu.:12.325  
##  Median :0.0000   Median :0.0000   Median :13.06   Median :12.728  
##  Mean   :0.2348   Mean   :0.2378   Mean   :13.04   Mean   :12.612  
##  3rd Qu.:0.0000   3rd Qu.:0.0000   3rd Qu.:13.16   3rd Qu.:13.006  
##  Max.   :1.0000   Max.   :1.0000   Max.   :17.08   Max.   :16.481  
##  NA's   :5                         NA's   :2       NA's   :2       
##      age65            milpop         unemployed       incspend2      
##  Min.   : 8.164   Min.   : 3.045   Min.   : 7.425   Min.   :   5355  
##  1st Qu.:10.452   1st Qu.: 5.517   1st Qu.: 8.816   1st Qu.: 220620  
##  Median :10.760   Median : 6.246   Median : 9.142   Median : 376741  
##  Mean   :10.819   Mean   : 6.777   Mean   : 9.170   Mean   : 450124  
##  3rd Qu.:11.215   3rd Qu.: 8.077   3rd Qu.: 9.544   3rd Qu.: 577283  
##  Max.   :14.552   Max.   :12.691   Max.   :13.147   Max.   :4987593  
##  NA's   :2        NA's   :2        NA's   :2        NA's   :3374
```


---


```r
boxplot(voteshare~inparty, data=OOS[OOS$year==1956,])
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---


```r
plot(voteshare~inparty, data=OOS[OOS$year==1956,])
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---

## Running a regression by year: Do you see a pattern?



```r
output.vector&lt;-NULL
for (i in unique(OOS$year)){
    output.vector[which(unique(OOS$year) == i)]&lt;- 
      lm(voteshare ~ inparty, data=OOS[OOS$year == i,])$coefficients[2]
}
plot(unique(OOS$year), output.vector, type="l", ylab="Coefficient (Presiden'ts party)", xlab="Year") 
abline(h=0, lty=3)
```

![](08DebugginAndProfiling_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;



---

## Functionalize it


- Now we might think -- there is a more general case where I want to get a bunch of seperate regression estimates on defined subsets of the data

```r
by.var.lm&lt;-function(by.var, formula, data, coef.num){
  output.vector&lt;-NULL
  for (i in unique(by.var)){
    output.vector[which(unique(by.var) == i)]&lt;- 
      lm(formula, data=data[by.var == i,])$coefficients[coef.num]
  }
  return(output.vector)
}
plot(by.var.lm(year, voteshare~inparty, OOS, 2), type="l")
```


---

## This is not working, what to do?

- As a first step, figure out where it's broken using `traceback`

```r
traceback(by.var.lm(year, voteshare~inparty, OOS, 2))
```



---

- A second thing to try is to use `debug`

```r
debug(by.var.lm)
```


---

- A second thing to try is to put a `broswer` function into the function itself

```r
browser()
```

---

- Another thing to try is just put in some various print commands



```r
by.var.lm&lt;-function(by.var, formula, data, coef.num){
  output.vector&lt;-NULL; print("one")
  for (i in unique(by.var)){ 
    print(i) # I can see where I get to in the loop
    output.vector[which(unique(by.var) == i)]&lt;- 
      lm(formula, data=data[by.var == i,])$coefficients[coef.num]
  }
  print('got out of loop')
  return(output.vector)
}
plot(by.var.lm(year, voteshare~inparty, OOS, 2), type="l")
```


---


## Class activity, debug the function and add comments

Do it

--- 


## So now I have a function that works, can I use it again?



```r
website&lt;-url("http://pages.wustl.edu/montgomery/titanic")
titanic&lt;-read.delim(website)
table(titanic$Gender)
table(titanic$Class)
```


---

## Make this work



```r
by.var.lm(Class, (as.numeric(Survived)-1) ~ Gender, titanic, 2)
```


---


# Benchmarking and code improvements


```r
x &lt;- runif(500)
system.time(sqrt(x))
```

```
##    user  system elapsed 
##       0       0       0
```


The goal is to see how long a function takes to evaluate

---


## Much better: microbenchmark



```r
library(microbenchmark)
microbenchmark(sqrt(x)) # evalues 100 times per default
```

```
## Unit: microseconds
##     expr min    lq  mean median   uq    max neval
##  sqrt(x) 3.1 3.202 4.357  3.551 5.25 14.601   100
```

```r
microbenchmark(sqrt(x), times=1000)
```

```
## Unit: microseconds
##     expr min    lq     mean median    uq    max neval
##  sqrt(x)   3 3.002 3.232811  3.101 3.201 12.401  1000
```

---

## Now we can compare different functions


```r
microbenchmark(sqrt(x), 
               x^0.5,
               times=1000)
```

```
## Unit: microseconds
##     expr    min     lq      mean median     uq    max neval
##  sqrt(x)  2.900  3.102  4.218413  3.202  5.201 22.901  1000
##    x^0.5 21.401 23.102 26.183301 23.701 25.851 84.801  1000
```



```r
microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2),
               times=1000)
```

```
## Unit: microseconds
##           expr    min     lq      mean median     uq       max neval
##        sqrt(x)  2.801  3.001  3.831507  3.101  3.501    42.201  1000
##          x^0.5 21.300 22.500 24.458290 22.802 23.601    69.401  1000
##        x^(1/2) 21.500 22.701 25.041934 23.101 24.001   116.101  1000
##  exp(log(x)/2) 51.300 53.201 84.979508 53.302 55.451 27721.101  1000
```


---

## And also completely different functions

```r
microbenchmark(sqrt(x), x^4-3*x)
```

```
## Unit: microseconds
##         expr    min     lq     mean median     uq    max neval
##      sqrt(x)  5.401  5.602  6.02902  5.801  6.101 13.600   100
##  x^4 - 3 * x 42.701 46.251 49.21696 50.101 50.901 64.401   100
```

---

- For ease of interpretation, if a microbenchmark takes
- 1 millisecond, then 1,000 calls take a second
- 1 microsecond, then 1,000,000 calls take a second
- 1 nanosecond,  then 1,000,000,000 calls take a second
- Or use unit=eps for evaluations per second


```r
microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2),
               unit="eps")
```

```
## Unit: evaluations per second
##           expr       min        lq      mean    median        uq       max
##        sqrt(x) 33782.642 263157.89 269847.71 285591.90 303030.30 333333.33
##          x^0.5 14641.074  39601.77  40116.01  42014.16  43288.17  45045.05
##        x^(1/2) 10537.297  39918.73  40646.96  41664.93  43101.59  44841.04
##  exp(log(x)/2)  3688.649  16638.70  16830.31  17888.77  18099.23  18796.99
##  neval
##    100
##    100
##    100
##    100
```


---

- Evaluating every function takes time
- Evaluating () or {} takes time
- Even specifying useless arguments in functions takes time!


```r
f0 &lt;- function() NULL
f1 &lt;- function(a=1) NULL
f2 &lt;- function(a=1, b=2) NULL
f3 &lt;- function(a=1, b=2, c=3) NULL
f4 &lt;- function(a=1, b=2, c=3, d=4) NULL
f5 &lt;- function(a=1, b=2, c=3, d=4, e=5) NULL
```


---


```r
microbenchmark(f0(), f1(), f2(), f3(), f4(), f5(), times=10000)
```

```
## Unit: nanoseconds
##  expr min  lq     mean median  uq    max neval
##  f0() 100 201 286.2179    201 201 474301 10000
##  f1() 100 201 316.5018    201 202 498600 10000
##  f2() 200 201 417.0632    201 301 954902 10000
##  f3() 200 201 429.6233    301 302 527902 10000
##  f4() 200 301 485.1675    301 400 594201 10000
##  f5() 300 301 525.5428    302 401 582301 10000
```


---

## There is room for improvement (or mistakes) in the most basic functions!
## Extracting one element of a data frame


```r
?mtcars
```

```
## starting httpd help server ... done
```

```r
head(mtcars)
```

```
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
```


---



```r
microbenchmark(
  "[32, 11]" = mtcars[32,11],
  "$carb[32]"	= mtcars$carb[32],
  "[[c(11, 32)]]" = mtcars[[c(11,32)]],
  "[[11]][32]" = mtcars[[11]][32],
  ".subset2" = .subset2(mtcars,11)[32])
```

```
## Unit: nanoseconds
##           expr   min    lq     mean  median      uq     max neval
##       [32, 11] 18201 23601 45138.98 25051.0 33701.0  777501   100
##      $carb[32]  2001  2801  4790.00  3501.5  4801.0   32901   100
##  [[c(11, 32)]]  8201 11001 87099.05 12201.0 16001.0 6448201   100
##     [[11]][32]  8001 10201 26032.99 10850.5 13001.5 1105501   100
##       .subset2   300   601  3279.98   701.5  1051.0  230301   100
```

---


# Vectorizing

- The key idea behind vectorizing your code is to think about entire
- vectors instead of thinking about their components. Using apply and co
- instead of for loops is a start, but does not really solve this issue.
- Truly vectorized functions will make use of code written in C instead 
 of R. Loops in C are much faster because they have much less overhead.

---

## Addition on each element of a data frame


```r
rm(list=ls())
m=5
n=5
matrix1 &lt;- replicate(m, rnorm(n)) # create matrix
matdf &lt;- matdf1 &lt;- data.frame(matrix1) 
matdf
```

```
##            X1         X2         X3          X4         X5
## 1  1.15623391 -0.3434230  1.3192186  0.02472827 -1.2180637
## 2 -0.11853735 -1.1718937 -0.7733746 -1.24383222  1.7367300
## 3  0.73609732 -0.5413431 -0.5904645 -0.18674351  1.9409586
## 4 -0.11920318 -1.5831623  0.0184468  0.22481360 -0.4039615
## 5 -0.02801814 -0.4657266 -1.8176748 -1.49718639 -0.1624772
```

---
  
  



```r
for (i in 1:m) {
  for (j in 1:n) {
    matdf1[i,j] &lt;- matdf1[i,j] + 1.87*cos(.25)*pi # addition
  }
}
matdf1
```

```
##         X1       X2       X3       X4       X5
## 1 6.848380 5.348723 7.011364 5.716874 4.474082
## 2 5.573608 4.520252 4.918771 4.448313 7.428876
## 3 6.428243 5.150802 5.101681 5.505402 7.633104
## 4 5.572942 4.108983 5.710592 5.916959 5.288184
## 5 5.664127 5.226419 3.874471 4.194959 5.529668
```

---


```r
matdf2&lt;-data.frame(matrix1) 
matdf2 &lt;- matdf2 + 1.87*cos(.25)*pi
matdf2
```

```
##         X1       X2       X3       X4       X5
## 1 6.848380 5.348723 7.011364 5.716874 4.474082
## 2 5.573608 4.520252 4.918771 4.448313 7.428876
## 3 6.428243 5.150802 5.101681 5.505402 7.633104
## 4 5.572942 4.108983 5.710592 5.916959 5.288184
## 5 5.664127 5.226419 3.874471 4.194959 5.529668
```


---


```r
microbenchmark(
  "loop" = for (i in 1:m) {
    for (j in 1:n) {
      matdf[i,j] &lt;- matdf[i,j] + 1.87*cos(.25)*pi
    }
  }, 
  "vectorized" = matdf &lt;- matdf + 1.87*cos(.25)*pi
)
```

```
## Unit: microseconds
##        expr      min       lq      mean     median         uq       max neval
##        loop 6497.302 9446.852 10801.723 10017.0510 11362.9005 22294.101   100
##  vectorized  402.100  698.951   927.392   815.6005   993.2005  3011.601   100
```


---


```r
mat1 &lt;- matrix(abs(rnorm(2500))+pi, ncol=50)
apply(mat1, 1, function(x) sum(x))
```

```
##  [1] 192.9160 195.6268 206.9533 191.9658 192.2874 199.2554 202.8432 208.2458
##  [9] 197.3414 192.1707 194.5580 199.3396 203.6287 199.4435 196.4993 197.6265
## [17] 204.7220 194.0310 197.7309 190.9498 199.3102 200.2248 203.5732 192.1998
## [25] 196.7457 192.4782 197.2125 190.1197 198.2704 195.6590 197.2405 195.2628
## [33] 197.1688 204.5037 198.4266 193.4762 193.0285 196.4312 190.2313 194.2725
## [41] 185.6900 194.4955 194.1304 203.7842 201.1553 193.3666 201.8238 205.0461
## [49] 195.7411 199.6389
```

```r
rowSums(mat1)
```

```
##  [1] 192.9160 195.6268 206.9533 191.9658 192.2874 199.2554 202.8432 208.2458
##  [9] 197.3414 192.1707 194.5580 199.3396 203.6287 199.4435 196.4993 197.6265
## [17] 204.7220 194.0310 197.7309 190.9498 199.3102 200.2248 203.5732 192.1998
## [25] 196.7457 192.4782 197.2125 190.1197 198.2704 195.6590 197.2405 195.2628
## [33] 197.1688 204.5037 198.4266 193.4762 193.0285 196.4312 190.2313 194.2725
## [41] 185.6900 194.4955 194.1304 203.7842 201.1553 193.3666 201.8238 205.0461
## [49] 195.7411 199.6389
```

---



```r
microbenchmark(apply(mat1, 1, function(x) sum(x)),
               rowSums(mat1))
```

```
## Unit: microseconds
##                                expr     min      lq     mean  median       uq
##  apply(mat1, 1, function(x) sum(x)) 155.701 213.751 334.0981 228.301 405.7010
##                       rowSums(mat1)  16.001  20.701  27.2910  22.751  32.5505
##       max neval
##  2050.901   100
##    66.901   100
```


---

- Even for basic tasks, think about the actual calculations you perform


```r
mat2 &lt;- matrix(sample(1:7, 90000, replace=T), ncol=300)
mat3 &lt;- matrix(sample(2:6, 90000, replace=T), ncol=300)
ys &lt;- sample(3:5, 300, replace=T)
```


---


```r
all.equal(mat2 %*% mat3 %*% ys , mat2 %*% (mat3 %*% ys))
```

```
## [1] TRUE
```

```r
microbenchmark(mat2 %*% mat3 %*% ys,
               mat2 %*% (mat3 %*% ys))
```

```
## Unit: microseconds
##                    expr       min        lq      mean    median        uq
##    mat2 %*% mat3 %*% ys 21015.801 22573.201 23795.972 23045.901 23724.601
##  mat2 %*% (mat3 %*% ys)   894.901  1415.251  1716.332  1446.901  1493.751
##      max neval
##  41678.2   100
##  14849.6   100
```

- Why?  Think through the dimensionality


---

## Paste/collapse and copies


```r
random_states &lt;- function() {
  paste(sample(state.name,10,replace =TRUE),collapse ="")
}
states10 &lt;- replicate(10, random_states())
states10
```

```
##  [1] "GeorgiaNew YorkAlabamaMinnesotaNorth CarolinaWyomingTennesseeWyomingIndianaDelaware"                     
##  [2] "IllinoisFloridaMontanaWest VirginiaMississippiIowaMinnesotaMississippiNew YorkUtah"                      
##  [3] "MichiganArizonaUtahOhioMarylandMississippiWest VirginiaWest VirginiaMinnesotaNorth Dakota"               
##  [4] "New JerseyNew MexicoNevadaRhode IslandWest VirginiaConnecticutFloridaMississippiConnecticutMassachusetts"
##  [5] "ColoradoIndianaNorth CarolinaVirginiaFloridaWashingtonMississippiFloridaMassachusettsAlabama"            
##  [6] "North CarolinaUtahSouth CarolinaNevadaOregonRhode IslandSouth DakotaNevadaIowaNorth Carolina"            
##  [7] "NebraskaWyomingNew MexicoWyomingLouisianaNew MexicoOklahomaVermontNew HampshireWyoming"                  
##  [8] "KansasVermontVirginiaUtahArkansasKansasTennesseeRhode IslandMichiganMissouri"                            
##  [9] "KentuckyMarylandColoradoMissouriMaineKentuckyNorth DakotaMinnesotaLouisianaMassachusetts"                
## [10] "OregonArkansasSouth CarolinaPennsylvaniaMississippiUtahNorth DakotaVirginiaIllinoisTennessee"
```

```r
states100 &lt;- replicate(100, random_states())
```


---


```r
collapse &lt;- function(states) {
  out &lt;- ""
  for (x in states) {
    out &lt;- paste0(out, x) # same as paste(..., sep="", collapse)
  }
  out
}
```

---


```r
microbenchmark(
  "loop10" = collapse(states10),
  "vec10" = paste(states10, collapse =""),
  "loop100" = collapse(states100),
  "vec100" = paste(states100, collapse ="")
)
```

```
## Unit: microseconds
##     expr      min       lq       mean    median        uq      max neval
##   loop10   43.901   56.251  128.51109   59.3515   65.8510 6638.200   100
##    vec10   12.202   17.451   22.06604   18.4015   22.2510  130.201   100
##  loop100 2231.101 2626.502 2767.80196 2680.4005 2844.8510 4363.301   100
##   vec100   91.701  140.001  161.28894  146.5505  161.7515  492.002   100
```

---

## Allocate memory and fill, don't append to the end

- Here, we are not only getting around using the loop, but also avoiding copies. 
- Whenever you append(), cbind(), rbind(), or paste() to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home. 
- If you're repeating this many times, like in a for loop, this can be quite computationally expensive.


---

### Class exercise

1. Make a new version of `by.var.lm`
2. Let's see which team can find the fastest implementation
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
