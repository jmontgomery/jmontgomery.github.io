# Data Types in R

## Functions
```{r}
log
log(2) # ln(2)
log(2, base=10) # log(2) base 10
log(base = 10, x = 2)
exp(log(1)) # e^ln(1) = 1
```

## Vectors
The c() function is used to collect/concatenate things together into a vector

```{r}
c(0,7,8)
x<-c(0,7,8) # assign this to a named object
```

An easy way to make a sequence vector is using the `:` operator. 

```{r}
numbers5to20 <- 5:20 # 
numbers5to20
```

Note that it always increments by 1

```{r}
1.5:10 
```

You can also concatenate any two vectors to make a new vector

```{r}
c(numbers5to20, x)
```

## Functions and vectors


Many functions have been "Vectorized" meaning that they work on each element in the vector

```{r}
numbers5to20*2
sqrt(numbers5to20)
log(numbers5to20)
abs(numbers5to20)
numbers5to20^2
```

But when you "Interact" two vectors, they will work "elementwise"

```{r}
numbers5to20*numbers5to20
numbers5to20+numbers5to20
numbers5to20+rev(numbers5to20) 
data <- c(NA, 4, 7, NA, 19)
is.na(data) #tells us true or false whether each value is NA
!is.na(data) #true if the value is *not* NA
```

Other functions operate on a functions work more directly

```{r}
sum(numbers5to20)
prod(numbers5to20) #multiples all elements together
mean(numbers5to20)
var(numbers5to20)
max(numbers5to20, na.rm=T) # maximum -- ignore missing data
min(numbers5to20, na.rm=TRUE) #minimum -- notice that T=TRUE
summary(numbers5to20)
```

Accessing elements of a vector or matrix is usually done with the [] operators

We can access the first or fortieth element of vap.

```{r}
numbers5to20[1] 
numbers5to20[40] 
```

We can also extract several elements at a time using vectors.

```{r}
numbers5to20[c(3,6,7)] 
numbers5to20[3:7]
```


We can repeat numbers as well

```{r}
numbers5to20[c(3,3,2,2)] 
```
This code prints everything but the 4th through 7th elements by using the negative sign

```{r}
numbers5to20[-(4:7)] 
```

```{r, eval=FALSE}
x
x*3 #scalar multiplication
y<-x-5 #simple addition and multiplicaiton are done "by element"
y
x^3 # ditto with exponents
y^x # but if each are three elements long, it will execute by element
```

Vector recycling

When vectors have different lengths, the shorter one is extended by 
repeating the vector.

This means two things: 
1. The vector lengths must be multiples of each other
2. This is a *very* easy way to make a bad, bad mistake.

You can easily find the length of a vector
```{r}
length(numbers5to20)
```

Other functions will create vectors as outputs


```{r}
rep(1, 5) #Repeat the value 1, 5 times
seq(1, 21, by=2) #Make the sequence 1 to 21 moving by increments of 2
rep(seq(2,20, by=2), 2) #Repeat the pattern 2, 4, ... 20, twice
rep(c(1,4), c(3,2)) #Repeat 1, 3 times and 4, twice
rep(c(1,4), each=3) #Repeat each value 3 times
```

## Logicals/Booleans

Logicals are often used when subsetting or recoding data

Generally necessary to understand this for data wrangling


```{r}
x<-c(0, 7, 8) 
chooser<-c(T, F, T)
x[chooser] # print ony those elements of x where chooser is TRUE
```

Arithmetic operations on logicals create numerics where:

- TRUE is treated as a '1', and
- FALSE is treated as a '0'

```{r}
sum(chooser) # Number of true values
```

### Boolean logic

```{r}
x == 7 #equals
x != 7 #does not equal
x > 7 #greater than
x >= 7 #greater than or equal to
x < 7 #less than
x <= 7 #less than or equal to

x < 7 | x == 7 ## the or operator
x <= 7 & x == 7 ## the and operator
```

"or" - the pipe symbol - returns true if either/any of the conditions are true
"and" - the ampersand - returns true if both/all of the conditions are true

Most of the time, we use boolean logic to subset datasets.

Here's some data to get us started
```{r}
vap<-voting.age.population<-c(3481823, 496387, 4582842, 2120139,26955438,
                              3617942,2673154,652189,472143,14085749,6915512,
                              995937,1073799,9600372,4732010,2265860,2068253,
                              3213141,3188765,1033632,4242214,4997677,7620982,
                              3908159,2139918,4426278,731365,1321923,1870315,1012033,
                              6598368,1452962,14838076,6752018,494923,8697456,2697855,
                              2850525,9612380,824854,3303593,594599,4636679,
                              17038979,1797941,487900,5841335,4876661,1421717,
                              4257230,392344)    


total.votes<-tv<-c(NA, 238307, 1553032, 780409,8899059,1586105, 
                   1162391,258053, 122356,4884544, 2143845,348988, 
                   458927,3586292, 1719351,1071509, 864083,1370062, 
                   954896,NA, 1809237, 2243835,3852008, 2217552,NA, 
                   2178278, 411061,610499, 586274,418550, 2315643,568597, 
                   4703830,2036451, 220479,4184072, NA,1399650, NA,392882, 
                   1117311,341105, 1868363,NA, 582561, 263025,2398589, 
                   2085074,473014, 2183155, 196217)

tv[!is.na(tv)] #get all valid datapoints from the tv dataset

small.states<- voting.age.population[voting.age.population < median(voting.age.population)]
small.states

state.size<-(voting.age.population > median(voting.age.population)) *1
state.size #this code makes a new vector equal to 1 if it's a large state (larger than median), 0 otherwise


which(state.size == 1) #returns the vector of indices of the elements that have state.size equal to 1

any(x>2) #returns true if the condition is true for any element

all(x>2) #returns true if the condition is true for all elements
```

## Characters/Strings

```{r}
colors <- c("red", "yellow", "blue", "green", "magenta", "cyan")

```
You might want only a portion of the string. 

```{r}
substr(colors, start=1, stop=2)

paste0(colors, "flowers") # combine two strings
paste(colors, "flowers", sep="") # combine two strings
paste("I like", colors, "flowers")
paste("I like", colors, "flowers", collapse = "")
nchar(colors) #how many characters in each string
```

You may want to divide a string into components

```{r}
extreme.statement<-"Coding is my life"
this.out<-strsplit(extreme.statement, split=" ")  
unlist(this.out)
```

Use gsub to replace or remove parts of a string
```{r}
gsub("my life", "the bee's knees", extreme.statement) 
# less extreme.  More true

gsub(" is my life", "", extreme.statement)
```

Tips for using strings:

- If you are doing a lot with strings try the library 'strgr', which has some user-friendly functions
- If you include '\n' in a string, in many instances it will be a carriage return (e.g., plotting)
- A very common programming error is to forget a closing quotation mark. This will make the computer think you are still making a giantly long string.

## Matrices

A matrix is just a collection of vectors

You can combine vectors by column using 'cbind'
```{r}
m1 <- cbind(vap, tv) 
head(m1)
```

Or you can combine by rows using 'rbind'
```{r}
m2 <- rbind(vap, tv)
head(m2)
```

We can access by 'matrixname[row, column]'
```{r}
m2[1,2] # first row, second column
m1[,1] # the 1st column
```

Can get a submatrix

```{r}
m1[1:5,1:2]
m2[1,1:10]
m2[1,1:10]
m2[1:2, 1:10]
m2[, 1:10] # same as previous line since there are only two rows.
class(m2)
```

Objects in R are simply pieces of data that contain specific attributes.

Classes define what attributes an object *must* have and *can* have.

Matrices always have an attribute that determines the number of rows and columns


```{r}
dim(m1) 
```

For any object you can look at it's attributes using (helpfully) the 'attributes' function

```{r}
attributes(m1) 
```
We see that the matrix also has another attribute


```{r}
dimnames(m1) 
```

The top refers to the row names (which do not exist)
The bottom are the column names (that were borrowed from the vectors used to construct the matrix).


You can also access these using functions


```{r}
colnames(m1)
colnames(m2)
rownames(m1)
rownames(m2)
```

And you can reset these using the same functions

```{r}
colnames(m1)<-c("Voting age population", "Total Votes")
colnames(m1)
```

You can also do this with the following

```{r}
dimnames(m1)[[2]][1]<-"Pigglywiggly"
head(m1) 
```

We have re-named the first column to have the name "Pigglywiggly"


We are able to do this because the output of 'dimnames' is a list

You can subset matrices with a boolean/logical matrix to get certain values from it just like you would a vector

Matrices (and vectors) can only contain one datatype

If you try to create one with multiple datatypes, it will convert everything to be the same datatype

## Matrix algebra (optional)

A couple of matrices
```{r}
H3<-matrix(c(1, 1/2, 1/3, 1/2, 1/3, 1/4, 1/3, 1/4, 1/5), nrow=3)
H3

1/cbind(seq(1,3), seq(2, 4), seq(3,5)) # most basic function continue to be "element wise"
H3+1
H3*2
H3^2
mean(H3) # others will treat the matrix as a vector no matter what
rowSums(H3) # others work on matrices in particular ways (more on this later)
colSums(H3)
rowMeans(H3)
colMeans(H3)
```

Logicals work too
```{r}
H3 == 1
H3 == c(1,2,3) # wha...?
H3 == H3
```

Some work like they do in the math books

```{r}
det(H3) # the determinant -- hard for you ... easy in R
diag(H3) # get the diagonal elements of amatrix
diag(1, nrow=3) # make a 3by3 identity matrix

t(H3) # matrix transpose
Hnew<-H3
Hnew[lower.tri(H3, diag=TRUE)] # extract the lower triangular elements of H3

# Get the trace
trace <- function(data) (sum(diag(data))) # our own little function .. more on this next time
trace(H3)

# Matrix multipication is %*%
t(H3)%*%H3
c(1,2,3)%*%c(1,2,3) # dot product
matrix(c(1,2,3), ncol=1)%*%c(1,2,3) # outer product

#matrix inversion
solve(H3)
invH3<-solve(H3)
H3%*%invH3 ## close enough?

# Why is it called solve?  It can also be used to solve linear systems.
b<-c(1,2,3)
b
solve(H3, b)
```

## Lists

Let's make a list that contains a *matrix*, a *vector*, and an *integer*.

```{r}
list.a<-list(m1, vap, 3) 
str(list.a)
```

This is the advantage of lists.  They can contain basically anything, even other lists

```{r}
vector1<-c(1,2,3)
gospels<-c("matthew","mark","luke", "john")
my.matrix<-matrix(c(1:20), nrow=4)
my.data<-data.frame(cbind(vap, tv))
my.crazy.list<-list(vector1, gospels, my.matrix, TRUE, list.a)
str(my.crazy.list)
```

Lists have attributes but we haven't set them yet

```{r}
attributes(my.crazy.list) 
```

This reports the number of major sub-elements in the list.  

```{r}
length(my.crazy.list) 
```

This won't work for complicated lists

```{r}
dim(my.crazy.list) 
```


We can give names to elements of a list

```{r}
names(my.crazy.list)<-c("OneTwoThree", "Gospels", 
                        "SmallMat", "OneLogical", "AnotherList")
str(my.crazy.list) 
```

Now each part of the list has a name attribute


Skip the steps above by doing the following:

```{r}
my.crazy.list<-list(OneTwoThree=vector1,
                    Gospels=gospels, 
                    SmallMat=my.matrix, 
                    OneLogical=TRUE, 
                    AnotherList=list.a)
str(my.crazy.list)
names(my.crazy.list)
```


There are at least four ways of accessing elements of a list

```{r}
my.crazy.list[[1]]

my.crazy.list$OneTwoThree

my.crazy.list[1]

my.crazy.list["OneTwoThree"]
```


You can add elements in a similarly confusing number of ways


```{r}
my.crazy.list$hocuspocus<-"hocuspocus"
str(my.crazy.list)
```

You can also access access/add to/subtract from the sub-elements themselves. We just add what we know about accessing elements of matrices/vectors/etc. to how we access lists.

```{r}
my.crazy.list[[3]][1,] # first row of my.matrix
my.matrix[1,]  #the same

```

But lists don't play well with basic commands. Only components of lists.

```{r}
#this won't work
#my.crazy.list + 2

#but this will!
my.crazy.list[[3]] + 2
```

## Arrays

Arrays are effectively matrices that can have more than 2 dimensions. An array with exactly two dimensions is a matrix.

The following example creates an array of two 3x4 matrices each with 3 rows and 4 columns.

```{r}

# Take the sequence from 1 to 24 as input to the array.
result <- array(1:24, dim=c(3,4,2))
result

# You can also name all of the dimensions.
column.names <- c("COL1","COL2","COL3","COL4")
row.names <- c("ROW1","ROW2","ROW3")
matrix.names <- c("Matrix1","Matrix2")

result2 <- array(1:24, dim=c(3,4,2), dimnames=list(row.names, column.names, matrix.names))
result2

# Print the third row of the second matrix of the array.
result[3,,2]

# Print the element in the 1st row and 3rd column of the 1st matrix.
result[1,3,1]

# Print the 2nd Matrix.
result[,,2]
```

## Dataframes

They are rectangular like a matrix, but each column can be of a different class and you can access elements of the data frame like it's a list.

```{r}
turnout <- tv/vap
voting.data <- data.frame(tv, vap, turnout)
head(voting.data)
str(voting.data)
```

There are at least four ways to access a variable
```{r}
head(voting.data[[1]])
head(voting.data$tv)
head(voting.data["tv"])
head(voting.data[,1])
```

```{r}
names(voting.data) #access the column names

# NOTE: dataframes always have column names!!

colnames(voting.data)
```

We can change back and forth between a matrix and a data frame

```{r}
as.data.frame(my.matrix)
data.frame(my.matrix)

head(as.matrix(voting.data))
```

- Sometimes all of this can be a bit cumbersome
- The 'with' command will run a function with the dataset slightly easier

```{r}
# these are equivalent
mean(voting.data$vap)
with(voting.data, mean(vap)) 
```


## General info

You can determine the type of a variable by calling class on it as follows
```{r}
class(vap)
```

There are functions to move back and forth between types ('as.class' functions)


```{r}
grp <- c("control", "treatment", "control", "treatment")
grp <- factor(grp)
as.integer(grp) 
```
You can also check if an object is a specific class.

```{r}
is.integer(vap) 
is.numeric(vap)
```


There are several types of these

```{r}
as.character(0:5) # Turning numbers into characters
as.logical(0:5) # All numbers but '0' become TRUE
```

But not all of them work
```{r}
as.numeric(c('1', '2', '3')) 
as.numeric(c('a', 'b', 'c')) 
```
