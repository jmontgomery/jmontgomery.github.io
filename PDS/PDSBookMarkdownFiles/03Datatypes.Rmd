# Data Types in R

## Functions
```{r}
log
log(2) # ln(2)
log(2, base=10) # log(2) base 10
log(base = 10, x = 2)
exp(log(1)) # e^ln(1) = 1
```

## Vectors
The c() function is used to collect/concatenate things together into a vector

```{r}
c(0,7,8)
x<-c(0,7,8) # assign this to a named object
```

An easy way to make a sequence vector is using the `:` operator. 

```{r}
numbers5to20 <- 5:20 # 
numbers5to20
```

Note that it always increments by 1

```{r}
1.5:10 
```

You can also concatenate any two vectors to make a new vector

```{r}
c(numbers5to20, x)
```

## Functions and vectors


Many functions have been "Vectorized" meaning that they work on each element in the vector

```{r}
numbers5to20*2
sqrt(numbers5to20)
log(numbers5to20)
abs(numbers5to20)
numbers5to20^2
```

But when you "Interact" two vectors, they will work "elementwise"

```{r}
numbers5to20*numbers5to20
numbers5to20+numbers5to20
numbers5to20+rev(numbers5to20) 
data <- c(NA, 4, 7, NA, 19)
is.na(data) #tells us true or false whether each value is NA
!is.na(data) #true if the value is *not* NA
```

Other functions operate on a functions work more directly

```{r}
sum(numbers5to20)
prod(numbers5to20) #multiples all elements together
mean(numbers5to20)
var(numbers5to20)
max(numbers5to20, na.rm=T) # maximum -- ignore missing data
min(numbers5to20, na.rm=TRUE) #minimum -- notice that T=TRUE
summary(numbers5to20)
```

Accessing elements of a vector or matrix is usually done with the [] operators

We can access the first or fortieth element of vap.

```{r}
numbers5to20[1] 
numbers5to20[40] 
```

We can also extract several elements at a time using vectors.

```{r}
numbers5to20[c(3,6,7)] 
numbers5to20[3:7]
```


We can repeat numbers as well

```{r}
numbers5to20[c(3,3,2,2)] 
```
This code prints everything but the 4th through 7th elements by using the negative sign

```{r}
numbers5to20[-(4:7)] 
```

```{r, eval=FALSE}
x
x*3 #scalar multiplication
y<-x-5 #simple addition and multiplicaiton are done "by element"
y
x^3 # ditto with exponents
y^x # but if each are three elements long, it will execute by element
```

Vector recycling

When vectors have different lengths, the shorter one is extended by 
repeating the vector.

This means two things: 
1. The vector lengths must be multiples of each other
2. This is a *very* easy way to make a bad, bad mistake.

You can easily find the length of a vector
```{r}
length(numbers5to20)
```

Other functions will create vectors as outputs


```{r}
rep(1, 5) #Repeat the value 1, 5 times
seq(1, 21, by=2) #Make the sequence 1 to 21 moving by increments of 2
rep(seq(2,20, by=2), 2) #Repeat the pattern 2, 4, ... 20, twice
rep(c(1,4), c(3,2)) #Repeat 1, 3 times and 4, twice
rep(c(1,4), each=3) #Repeat each value 3 times
```

## Logicals/Booleans

Logicals are often used when subsetting or recoding data

Generally necessary to understand this for data wrangling


```{r}
x<-c(0, 7, 8) 
chooser<-c(T, F, T)
x[chooser] # print ony those elements of x where chooser is TRUE
```

Arithmetic operations on logicals create numerics where:

- TRUE is treated as a '1', and
- FALSE is treated as a '0'

```{r}
sum(chooser) # Number of true values
```

### Boolean logic

```{r}
x == 7 #equals
x != 7 #does not equal
x > 7 #greater than
x >= 7 #greater than or equal to
x < 7 #less than
x <= 7 #less than or equal to

x < 7 | x == 7 ## the or operator
x <= 7 & x == 7 ## the and operator
```

"or" - the pipe symbol - returns true if either/any of the conditions are true
"and" - the ampersand - returns true if both/all of the conditions are true

Most of the time, we use boolean logic to subset datasets.

Here's some data to get us started
```{r}
vap<-voting.age.population<-c(3481823, 496387, 4582842, 2120139,26955438,
                              3617942,2673154,652189,472143,14085749,6915512,
                              995937,1073799,9600372,4732010,2265860,2068253,
                              3213141,3188765,1033632,4242214,4997677,7620982,
                              3908159,2139918,4426278,731365,1321923,1870315,1012033,
                              6598368,1452962,14838076,6752018,494923,8697456,2697855,
                              2850525,9612380,824854,3303593,594599,4636679,
                              17038979,1797941,487900,5841335,4876661,1421717,
                              4257230,392344)    


total.votes<-tv<-c(NA, 238307, 1553032, 780409,8899059,1586105, 
                   1162391,258053, 122356,4884544, 2143845,348988, 
                   458927,3586292, 1719351,1071509, 864083,1370062, 
                   954896,NA, 1809237, 2243835,3852008, 2217552,NA, 
                   2178278, 411061,610499, 586274,418550, 2315643,568597, 
                   4703830,2036451, 220479,4184072, NA,1399650, NA,392882, 
                   1117311,341105, 1868363,NA, 582561, 263025,2398589, 
                   2085074,473014, 2183155, 196217)

tv[!is.na(tv)] #get all valid datapoints from the tv dataset

small.states<- voting.age.population[voting.age.population < median(voting.age.population)]
small.states

state.size<-(voting.age.population > median(voting.age.population)) *1
state.size #this code makes a new vector equal to 1 if it's a large state (larger than median), 0 otherwise


which(state.size == 1) #returns the vector of indices of the elements that have state.size equal to 1

any(x>2) #returns true if the condition is true for any element

all(x>2) #returns true if the condition is true for all elements
```

## Characters/Strings

```{r}
colors <- c("red", "yellow", "blue", "green", "magenta", "cyan")

```
You might want only a portion of the string. 

```{r}
substr(colors, start=1, stop=2)

paste0(colors, "flowers") # combine two strings
paste(colors, "flowers", sep="") # combine two strings
paste("I like", colors, "flowers")
paste("I like", colors, "flowers", collapse = "")
nchar(colors) #how many characters in each string
```

You may want to divide a string into components

```{r}
extreme.statement<-"Coding is my life"
this.out<-strsplit(extreme.statement, split=" ")  
unlist(this.out)
```

Use gsub to replace or remove parts of a string
```{r}
gsub("my life", "the bee's knees", extreme.statement) 
# less extreme.  More true

gsub(" is my life", "", extreme.statement)
```

Tips for using strings:

- If you are doing a lot with strings try the library 'strgr', which has some user-friendly functions
- If you include '\n' in a string, in many instances it will be a carriage return (e.g., plotting)
- A very common programming error is to forget a closing quotation mark. This will make the computer think you are still making a giantly long string.

## Matrices

## Lists

## Dataframes

## General info

You can determine the type of a variable by calling class on it as follows
```{r}
class(vap)
```

There are functions to move back and forth between types ('as.class' functions)


```{r}
grp <- c("control", "treatment", "control", "treatment")
grp <- factor(grp)
as.integer(grp) 
```
You can also check if an object is a specific class.

```{r}
is.integer(vap) 
is.numeric(vap)
```


There are several types of these

```{r}
as.character(0:5) # Turning numbers into characters
as.logical(0:5) # All numbers but '0' become TRUE
```

But not all of them work
```{r}
as.numeric(c('1', '2', '3')) 
as.numeric(c('a', 'b', 'c')) 
```
