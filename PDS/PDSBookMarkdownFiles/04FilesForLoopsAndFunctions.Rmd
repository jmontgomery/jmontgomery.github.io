# Files, For Loops, and Functions

## The working directory

First we want to change the working directory.  This is the folder where R will save and look for data by default (although you can always override this)

Note that the file path (in Windows at least) requires slashes. You can either use two back slashes to separate folders or one forward slash.

```{r, eval=FALSE}
setwd("~/Dropbox/Classes/R Programming")
## For Windows, will need to be something like
setwd("C:\\Documents and Settings\\Jacob Montgomery\\My Documents\\RWork")
## or
setwd("C:/Documents and Settings/Jacob Montgomery/My Documents/RWork")
## or
setwd(file.path("C:", "Documents and Settings", "Jacob Montgomery", "My Documents", "RWork"))
```

## Input and output

```{r, eval=FALSE}
voting.data<-data.frame(vap, tv)
```

Now let's save our newly created dataset
```{r, eval=FALSE}
dump("voting.data", "voting.data.R") # inputs are string.  Note that you must put the *.R in yourself
```

You might also want to save multiple objects
```{r, eval=FALSE}
dump(c("vap", "tv"), "voting.data.vectors.R")
dump(list=objects(), "everything.R")
## an alternative we can just use the command
save.image("everything.RData") # saves an image of your current workspace
```

Now we can clear our wokspace, and load these objects
```{r, eval=FALSE}
rm(list=ls())
source("voting.data.vectors.R")
ls() # only saved objects present
```

To read/write dataframes from/to a csv (comma separated values) file, the following commands will be useful
```{r, eval=F}
votes.06<-read.csv("~/Dropbox/Classes/R Programming/R Scripts/VotingData2006.csv", header=T)
write.csv(votes.06, file="VD06.csv")
```
Tips: All of the functions for reading in data are actually using the scan() function. No matter how crazy your data look, you can *always* read it into R by clever use of scan().


## if, else, ifelse

The basic syntax for an `if` call is

```{r, eval=FALSE}
if(condition){
  commands to run
}
```

- The inputs in the parentheses needs can be anything that returns a logical.  
- You can put anything you want in the braces

The simplest examples possible.

```{r}
if(TRUE) {
  print("I got here")
}

if(FALSE){ 
  print("I can't get here")
}
```

You can combine this with `else` 

```{r, eval=FALSE}
if(condition) {
  commands to run when condition is TRUE
} else { # notice that these are on the same line
  commands to run when the condition is FALSE
}
```


```{r}
x = 10
if(x > 2) {
  print("X is larger than 2")
} else { 
  print("X is 2 or smaller")
}
```

But this set up will not play well with vectors.  It runs, but is confusing

```{r}
if (c(3, 1) > 2){
  print("This won't work")
}

```

The `ifelse` command works nicely with vectors, but syntax is different. This command is equivalent to a ternary in other languages if you're familiar with that term.

```{r, eval=FALSE}
ifelse(condition, return when condition T, return when condition F) 
```

```{r}
x = c(0, 2)
ifelse(x > 1, "yes", "no") 
```


WARNING

If your outputs are vectors `ifelse` will work element-wise


```{r}
yes = c("yes1", "yes2")
no = c("no1", "no2")
ifelse(x > 1, yes, no)
ifelse(x < 2, yes, no)
```

- Note that the curly braces are not technically necessary if you have only a one line command 
- BUT you should use them anyway so someone can read your code!

```{r}
x = 3
if (x > 2) y = 2 * x else y = 3 * x
y
```

## repeat and while

- Repeat just repeats commands in the braces until it sees a `BREAK` command
- If you don't include `BREAK` your computer will be in an infinite loop.
- Save your work before using!
- Or maybe just don't use it

```{r, eval=FALSE}
repeat{ stuff to do until it sees BREAK }
```

```{r, fig.height=4, fig.align="center"}
# make a blank plot with the limits set by those vectors
plot(NULL, xlim=c(0, 100), ylim=c(0, 1), xlab="x", ylab="1/x") 
x = 1
repeat {
  y = 1 / x
  x = x + 1
  points(x, y)
  if (x == 100) { 
    break 
  }
}
```


A while loop is just a repeat, where the break condition is specified at the top


```{r, eval=FALSE}
while(condition){
  commands that repeat until condition flips to FALSE
}
```


```{r, fig.height=4, fig.align="center"}
plot(NULL, xlim=c(0, 100), ylim=c(0, 1), xlab="x", ylab="1/x") 
x = 1
while(x < 100) {
  y = 1 / x
  x = x + 1
  points(x, y)
}
```

## for loops

- The `for` command is probably the most common flow control option.
- It has three basic parts:
    + An object name that will be used in the following commands
    + A vector that we will "loop over"
    + Commands that will be executed for each value of the vector


```{r, eval=FALSE}
for (name in vector){
  execute these commands using each value of the vecotr
}
```

```{r}
for (monkey in c("Spider", "Howler", "Rhesus")) {
  ## Each loop does the equivalent of: monkey = "Spider" or monkey = "Howler" or ...
  print(monkey)
}
```

Or more commonly

```{r}
for (i in 1:10){
  print(i)
}
```


```{r, fig.height=4, fig.align="center"}
## for loops are very useful in many situations
plot(NULL, xlim=c(0, 100), ylim=c(0, 1))
for (i in 1:100) {
  points(i, 1 / i)
}
```


### next and break

Sometimes you might not want to execute the commands for every element in the vector
use the `next` command to skip (you can also use the `break`)
```{r}
some.odds = NULL
for (i in 1:200) {
  if (i %% 2 == 0) {
    next
  }
  some.odds = c(some.odds, i)
}
some.odds
```


Technically, you don't have to be so formal. But the indenting and braces are there for the protection of your future self.


```{r}
for (i in 1:10) print(i)
```


## Functions

### The basics

1. Use the 'function' command and assign it to an object
2. If you need, specify the expected inputs
3. Do some stuff
4. Return something (and only one thing) to the global environment.

```{r, eval=FALSE}
my.function = function(x) {
  do stuff here
  return(output)
}
```

Here's an example:

```{r}
countThrees = function(vector) {
  threes <- 0
  for(i in vector) {
    if(i == 3) {
      threes <- threes + 1
    }
  }
  return(threes)
}

v <- c(1, 2, 3, 4, 3, 3)
countThrees(v)
```

What would happen if we passed in one number instead of a vector?

```{r}
countThrees(2)
countThrees(3)
```

Or a matrix?

```{r}
m <- matrix(1:24, 4, 6)
countThrees(m)
```

If you want to return multiple values in R, you must put them in a vector or list and return the data structure instead.

Remember that a list is essentially a vector that can contain different data types.

Sometimes a function will return a value, but other times it will just execute a command like print or plot.


## Setting defaults

You can set default values for some of your arguments or all of them

```{r}
gaga.equation = function(num.rah=2, num.ah=3, num.ga=2, num.la=2, num.oo=1) {
  rahs = paste(rep("RAH", num.rah), collapse=", ")
  ahs  = paste(rep("AH", num.ah), collapse=", ")
  gas  = paste(rep("GA", num.ga), collapse=", ")
  oo   = paste(rep("OO", num.oo), collapse=", ")
  las  = paste(rep("LA", num.la), collapse=", ")
  paste(rahs, ",", ahs,  "!  ROMA, ROMAMA!", gas, ",", oo, las)
}

gaga.equation()
gaga.equation(num.rah=5)
```

If an argument (sometimes called a parameter) does not have a default value, it *must* be specified when the function is called.


## Scope

In the example above, if we tried to print rahs outside of the function, we would get an error. The variable rahs doesn't exist in the global environment.

```{r, eval=FALSE}
print(rahs)
```

What happens in the function, stays in the function

Remember that for loop variables can be accessed after the loop.

```{r}
for(i in 1:4) {
  print(i+2)
}
print(i)

```
Note that i equals 4 (its last loop value) after the loop is finished.

This is different from functions because the only way to retain access to a local variable that was created in the function is to return it.

```{r}
a <- 10
outer_func <- function() {
  a <- 20
  inner_func <- function() {
    a <- 30
    print(a)
  }
  inner_func()
  print(a)
}
outer_func()
a
```

If you try to run inner\_func(), it will say "Error in inner\_func() : could not find function "inner_func"" because that function is *actually*
a local object inside the function outer\_func. That means that outer\_func is the only place that can use inner\_func.

Scope kind of works like a bunch of one way mirrors. If I write a function, it can access all global variables and local (to the function) variables,
but the global environment can only access global variables. In the above code example, inner\_func can access all of its variables, all of outer\_func's variables,
and the global environment variables as well.

### Advanced scope topics

In R, there's a superassignment operator which is <<-

This assigns the variable to one environment up from its current location. Check out these examples and try to follow along with the environments.

This example will replace the global variable a (which used to store 10) with 20 from the outer\_func code. Printing a at the end of the script will print 20 this time.

```{r}
a <- 10
outer_func <- function() {
  a <<- 20
  inner_func <- function() {
    a <- 30
    print(a)
  }
  inner_func()
  print(a)
}
outer_func()
a
```

This example will replace a from the outer\_func environment with the value 30 so when outer\_func prints a, it will now contain 30.

```{r}
a <- 10
outer_func <- function() {
  a <- 20
  inner_func <- function() {
    a <<- 30
    print(a)
  }
  inner_func()
  print(a)
}
outer_func()
a
```

