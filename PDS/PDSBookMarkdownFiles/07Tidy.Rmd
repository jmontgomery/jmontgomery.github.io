# dplyr and tidy

## Into the tidyverse

- `dplyr` is a handy package for changing data
- `tidyr` is a handy package for reshaping data
- In combination they offer a powerful way to quickly extract insight from your data

### Our example

Data comes from fivethirtyeight.com
```{r, eval=TRUE, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)
library(readr)
primaryPolls<-read_csv('https://jmontgomery.github.io/PDS/Datasets/president_primary_polls_feb2020.csv')
primaryPolls$start_date<-as.Date(primaryPolls$start_date, "%m/%d/%y")

class(primaryPolls)
```

- A tibble is basically a data frame 
- They are both friendlier and more structured than traditional data frames


```{r, eval=TRUE, message=FALSE, warning=FALSE}
primaryPolls
```

You can also print the first 10 rows of all the columns

```{r, eval=TRUE, message=FALSE, warning=FALSE}
print(primaryPolls, width=Inf)
```

- You can access elements basically the same way
- They never allow partial matching (which is evil anyways)
    - Partial matching allows you to type the first few characters of a column name and it will figure out which one you meant
- You can use `as.tibble` or `as.data.frame` to jump back and forth


## Back to `dplyr`

- Subset data by rows: `filter`
- Reorder by rows: `arrange`
- Subset data by column: `select`
- Create new variables as a function of other variables: `mutate`
- Collapse values down (or extract statistic): `summarise`
- We can use `group_by` to make changes in the scope

### `filter`

- `filter` allows you to easily subset data using conditions as we have done before using accessors

```{r, eval=TRUE, message=FALSE, warning=FALSE}
filter(primaryPolls, candidate_name == c("Amy Klobuchar"))

```
- Or you can include multiple conditions

```{r, eval=TRUE, message=FALSE, warning=FALSE}
filter(primaryPolls, 
       candidate_name == c("Amy Klobuchar"), 
       state=="New Hampshire")

```

- Everything you have already learned about boolean operators applies here.

### `arrange`

- `arrange`  does the same thing, but organizes data by rows insead of subsetting by rows.

```{r, eval=TRUE, message=FALSE, warning=FALSE}
arrange(primaryPolls, state, pollster_id)
```

- Or in descending order

```{r, eval=TRUE, message=FALSE, warning=FALSE}
arrange(primaryPolls, state, desc(pollster_id))
```

### `select`

- Select is just a much easier way to subset by column


```{r, eval=TRUE, message=FALSE, warning=FALSE}
select(primaryPolls, state, candidate_name, start_date)
```

- It comes with a nice syntax for doing this without just listing
- `var1:var20` will select all columns between these two
- `-var1:var20` will select everything *except* that range
- `starts_with("cand")` will select columns that start with "cand"
- Similar functionality for `ends_with`, `contains`, and matches


A fun trick to move your favorite variables to the front, but keep it all:

```{r, eval=TRUE, message=FALSE, warning=FALSE}
select(primaryPolls, state, candidate_name, start_date, everything())
```


- Note here that `rename` is the mythical easy way to rename a column, although syntax seems backwards
- You have to specify the new column name on the left side of the equal sign and the old column name on the right

```{r, eval=TRUE, message=FALSE, warning=FALSE}
basicPolls<-select(primaryPolls, state, candidate_name, start_date, pct)
rename(basicPolls, candidate = candidate_name)
```

### `mutate`

- `mutate` allows us to create a new variable that is a function of the others
- If you want to add the new column(s) to your existing tibble, you must use the assignment operator.
    - Otherwise it will just print it out and throw the results away

```{r, eval=TRUE, message=FALSE, warning=FALSE}
mutate(basicPolls, proportion=pct/100)

basicPolls <- mutate(basicPolls, proportion=pct/100)
```

- transmute creates and returns a new tibble with only the mutated variable(s)

```{r, eval=TRUE, message=FALSE, warning=FALSE}
transmute(basicPolls, proportion=pct/100)

transmute(primaryPolls, numberRespondents=round((pct/100)*sample_size))

transmute(primaryPolls, 
          proportion=pct/100,
          numberRespondents=round(proportion*sample_size),
          )
```

- Note that you can use a ton of the basic functions we have already covered like `sum`, `mean`, `sqrt`, etc.
- A useful one is `n()`, which just counts the number of observations
- This includes logical comparisons

```{r, eval=TRUE, message=FALSE, warning=FALSE}
mutate(basicPolls, top_tier=(pct>10)*1)
```

### `summarise`

- We can easily extract summary statistics


```{r, eval=TRUE, message=FALSE, warning=FALSE}
summarise(basicPolls, average_candidate=mean(pct), count=n())
```

- This is more powerful when also using the `group_by` function

```{r, eval=TRUE, message=FALSE, warning=FALSE}
basicPolls_grouped<-group_by(basicPolls, candidate_name)
summarise(basicPolls_grouped, average_candidate=mean(pct), count=n())

basicPolls_grouped<-group_by(basicPolls, candidate_name, state)
summarise(basicPolls_grouped, average_candidate=mean(pct), count=n())
```

### Piping

- The tidyverse includes a nice syntax for combining multiple commands so we don't have to create new objects all of the time.
- The `%?%` syntax allows us to pass on the results of one line to another
- The result from the left side of the `%>%` is passed as the first parameter of the next function

```{r, eval=TRUE, message=FALSE, warning=FALSE}
basicPolls %>%
  group_by(candidate_name, state) %>%
  summarise(average_candidate=mean(pct), count=n())
```

- The above code is equivalent to the following:

```{r, eval=TRUE, message=FALSE, warning=FALSE}
summarise(group_by(basicPolls, candidate_name, state), average_candidate=mean(pct), count=n())
```

- Which is equivalent to this:

```{r, eval=TRUE, message=FALSE, warning=FALSE}
grouped_by <- group_by(basicPolls, candidate_name, state)
summarise(grouped_by, average_candidate=mean(pct), count=n())
```

- See assigned readings for more useful summary variables and `ungroup`

```{r, eval=TRUE, message=FALSE, warning=FALSE}
basicPolls %>%
  group_by(candidate_name, state) %>%
  summarise(average_candidate=mean(pct), count=n()) %>%
  filter(count>10)
```


```{r, eval=TRUE, message=FALSE, warning=FALSE}
primaryPolls %>%
  group_by(candidate_name, state) %>%
  summarise(average_candidate=mean(pct), count=n()) %>%
  filter(count>10) %>%
  mutate(average_prop=average_candidate/100) %>%
  select(average_prop, candidate_name, state, count)
```

### Pivots

- In many cases the data is not quite organized the way we want.
- Right now we have each poll as a separate row.  But what if we want each candidate to be a row so we can analyze their trends in polls over time?
- Or what if we get the trend line and want to instead reorganize to look at each poll separately?
- The key commands here are `pivot_wider` and `pivot_longer`
- See Chapter 12 for some additional (but less universally useful functions)



- In our running example we have one entry for each poll.  How could we combine these to list the result from each unique poll togehter?
- The key here is that the *values* of interest are in the `pct` column and the *groupings* of interest are in the candidates column

```{r, eval=TRUE, message=FALSE, warning=FALSE}
nevadaPrimaries<-primaryPolls %>%
 filter(candidate_name %in% c("Amy Klobuchar", "Bernard Sanders", "Elizabeth Warren", "Joseph R. Biden Jr.", "Michael Bloomberg", "Pete Buttigieg")) %>%
  filter(state=="Nevada") %>%
  select(candidate_name, pct, start_date, sample_size)
print(nevadaPrimaries, n=Inf)
```
- setting `n=Inf` in the print will ensure that all rows are shown (the equivalent for columns is `width=Inf`)
- `nevadaPrimaries` contains one row for every combination of a Nevada poll (specified by `start_date` and `sample_size`) and a candidate


```{r, eval=TRUE, message=FALSE, warning=FALSE}
wideNevada<-pivot_wider(nevadaPrimaries, names_from = candidate_name, values_from = pct)
print(wideNevada, width=Inf)
```

- `wideNevada` contains one row for every Nevada poll and a column for the pct each candidate got

```{r, eval=TRUE, message=FALSE, warning=FALSE}
dim(nevadaPrimaries)
dim(wideNevada)
```


- Or we could organize it into a time series ....

```{r, eval=TRUE, message=FALSE, warning=FALSE}
timeNevada<-pivot_wider(nevadaPrimaries, id_cols=candidate_name, 
                        names_from = c(start_date), values_from = pct)
print(timeNevada, width=Inf)
```

- Of course sometimes we want to do the reverse using `pivot_longer`
- In this case, we no longer have a single indicator variable for the values of `start_date`


```{r, eval=TRUE, message=FALSE, warning=FALSE}
timeNevada %>%
  select(candidate_name, `2020-01-08`, `2020-01-06`) %>%
  pivot_longer(c(`2020-01-08`, `2020-01-06`), names_to = "start_date_test", values_to = "pct_test")
```

- This will partially undo the `pivot_wider` command above
- Now, each row is a combination of one of the six candidates and one of the two start dates
- Note that to get this, we used `names_to` and `values_to` instead of `names_from` and `values_from`
