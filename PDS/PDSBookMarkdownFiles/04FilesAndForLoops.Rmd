# Files and For Loops

## The working directory

First we want to change the working directory.  This is the folder where R will save and look for data by default (although you can always override this)

Note that the file path (in Windows at least) requires slashes. You can either use two back slashes to separate folders or one forward slash.

```{r, eval=FALSE}
setwd("~/Dropbox/Classes/R Programming")
## For Windows, will need to be something like
setwd("C:\\Documents and Settings\\Jacob Montgomery\\My Documents\\RWork")
## or
setwd("C:/Documents and Settings/Jacob Montgomery/My Documents/RWork")
## or
setwd(file.path("C:", "Documents and Settings", "Jacob Montgomery", "My Documents", "RWork"))
```

## Input and output

```{r, eval=FALSE}
voting.data<-data.frame(vap, tv)
```

Now let's save our newly created dataset
```{r, eval=FALSE}
dump("voting.data", "voting.data.R") # inputs are string.  Note that you must put the *.R in yourself
```

You might also want to save multiple objects
```{r, eval=FALSE}
dump(c("vap", "tv"), "voting.data.vectors.R")
dump(list=objects(), "everything.R")
## an alternative we can just use the command
save.image("everything.RData") # saves an image of your current workspace
```

Now we can clear our wokspace, and load these objects
```{r, eval=FALSE}
rm(list=ls())
source("voting.data.vectors.R")
ls() # only saved objects present
```

To read/write dataframes from/to a csv (comma separated values) file, the following commands will be useful
```{r, eval=F}
votes.06<-read.csv("~/Dropbox/Classes/R Programming/R Scripts/VotingData2006.csv", header=T)
write.csv(votes.06, file="VD06.csv")
```
Tips: All of the functions for reading in data are actually using the scan() function. No matter how crazy your data look, you can *always* read it into R by clever use of scan().


## if, else, ifelse

The basic syntax for an `if` call is

```{r, eval=FALSE}
if(condition){
  commands to run
}
```

- The inputs in the parentheses needs can be anything that returns a logical.  
- You can put anything you want in the braces

The simplest examples possible.

```{r}
if(TRUE) {
  print("I got here")
}

if(FALSE){ 
  print("I can't get here")
}
```

You can combine this with `else` 

```{r, eval=FALSE}
if(condition) {
  commands to run when condition is TRUE
} else { # notice that these are on the same line
  commands to run when the condition is FALSE
}
```


```{r}
x = 10
if(x > 2) {
  print("X is larger than 2")
} else { 
  print("X is 2 or smaller")
}
```

But this set up will not play well with vectors.  It runs, but is confusing

```{r}
if (c(3, 1) > 2){
  print("This won't work")
}

```

The `ifelse` command works nicely with vectors, but syntax is different. This command is equivalent to a ternary in other languages if you're familiar with that term.

```{r, eval=FALSE}
ifelse(condition, return when condition T, return when condition F) 
```

```{r}
x = c(0, 2)
ifelse(x > 1, "yes", "no") 
```


WARNING

If your outputs are vectors `ifelse` will work element-wise


```{r}
yes = c("yes1", "yes2")
no = c("no1", "no2")
ifelse(x > 1, yes, no)
ifelse(x < 2, yes, no)
```

- Note that the curly braces are not technically necessary if you have only a one line command 
- BUT you should use them anyway so someone can read your code!

```{r}
x = 3
if (x > 2) y = 2 * x else y = 3 * x
y
```

## repeat and while

- Repeat just repeats commands in the braces until it sees a `BREAK` command
- If you don't include `BREAK` your computer will be in an infinite loop.
- Save your work before using!
- Or maybe just don't use it

```{r, eval=FALSE}
repeat{ stuff to do until it sees BREAK }
```

```{r, fig.height=4, fig.align="center"}
# make a blank plot with the limits set by those vectors
plot(NULL, xlim=c(0, 100), ylim=c(0, 1), xlab="x", ylab="1/x") 
x = 1
repeat {
  y = 1 / x
  x = x + 1
  points(x, y)
  if (x == 100) { 
    break 
  }
}
```


A while loop is just a repeat, where the break condition is specified at the top


```{r, eval=FALSE}
while(condition){
  commands that repeat until condition flips to FALSE
}
```


```{r, fig.height=4, fig.align="center"}
plot(NULL, xlim=c(0, 100), ylim=c(0, 1), xlab="x", ylab="1/x") 
x = 1
while(x < 100) {
  y = 1 / x
  x = x + 1
  points(x, y)
}
```

## for loops

- The `for` command is probably the most common flow control option.
- It has three basic parts:
    + An object name that will be used in the following commands
    + A vector that we will "loop over"
    + Commands that will be executed for each value of the vector


```{r, eval=FALSE}
for (name in vector){
  execute these commands using each value of the vecotr
}
```

```{r}
for (monkey in c("Spider", "Howler", "Rhesus")) {
  ## Each loop does the equivalent of: monkey = "Spider" or monkey = "Howler" or ...
  print(monkey)
}
```

Or more commonly

```{r}
for (i in 1:10){
  print(i)
}
```


```{r, fig.height=4, fig.align="center"}
## for loops are very useful in many situations
plot(NULL, xlim=c(0, 100), ylim=c(0, 1))
for (i in 1:100) {
  points(i, 1 / i)
}
```


### next and break

Sometimes you might not want to execute the commands for every element in the vector
use the `next` command to skip (you can also use the `break`)
```{r}
some.odds = NULL
for (i in 1:200) {
  if (i %% 2 == 0) {
    next
  }
  some.odds = c(some.odds, i)
}
some.odds
```


Technically, you don't have to be so formal. But the indenting and braces are there for the protection of your future self.


```{r}
for (i in 1:10) print(i)
```
