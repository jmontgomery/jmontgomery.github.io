[
["index.html", "Political Data Science 1 Don’t be a clown 1.1 As easy as cake 1.2 Class structures", " Political Data Science Jacob Montgomery and Mariah Yelenick 1 Don’t be a clown I see miracles all around me Stop and look around, it’s all astounding Water, fire, air and dirt Fucking magnets, how do they work? And I don’t wanna talk to a scientist Y’all motherfuckers lying, and getting me pissed — Insane Clown Posse, Miracles Link if you don’t know what I’m talking about Pollsters are wizards, shamans, diviners. They toss numbers around the way astragalomancers once tossed bones to foretell events to come. (The name comes from the Greek astragalos, meaning “knucklebone.” But you knew that.) I have never been called by a political pollster and don’t know anybody who has, but I know some pollsters, who assure me they don’t make the numbers up, and I believe them. — Roger Simon, Chief Political Columnist, Politico Link Depending on who you listen to, artificial intelligence and machine learning1 are either the cause or the solution to all of the world’s problems. On the one hand you have algorithms spreading misinformtion, large scale corporate surveillance, and predicted mass unemployment in the service sector. On the other hand you have ever-improving health diagnostics, data-driven journalism, and all the world’s information at the touch of your fingers (or voice). The term “data science” means different things to different people, but for most people the term doesn’t mean much at all. In the two quotes above, we see both the Insane Clown Posse and Politico’s (for God’s sake) chief political columnist share a loving embrace with ignorance about fundamental forces in our life. We swim in data and statistics. News, politics, and policy is increasingly being driven by data and algorithms. But all too few people know much about how these algorithms work. Like magnets or random sampling, data science is just a mysterious force that we have to cope with. The central goal of this class is to make sure you don’t have to be a clown. In today’s world, your future career will surely You will find that data science, machine learning, big data, and artificial intelligence is just another tool (if a powerful tool). It is neither good nor evil by itself. It is humans and human judgement (or lack of judgement) that lead to good our bad outcomes. But whether you intend to work for the forces of good or evil (I tend towards chaotic neutral) 1.1 As easy as cake One way 1.1.1 Coding 1.1.2 Data acquision Is that polling data you are looking at a random sample of Americans, or just everyone who attended that sick Delta Sig party? Were the people in your data randomly assigned to watch Fox news, or did they choose to? No matter how fancy your machine learning algorithm, the results don’t mean anything very much if you don’t 1.1.3 Algorithms 1.1.4 Domain knowledge Like baking, the final thing you need to do good data science is what most people call “domain knowledge” and what I call “knowing what the hell you are talking about.” It turns out that having a really cool statistical model, huge amounts of data, and even a super computer sproting 24 GPUs will not save you from reaching the wrong answer if you don’t think (and aren’t trained to think). Link 1.1.5 Putting it together A final method. You can get along fine in may cases following the instructions on the back of the chocolate chip cookie bag. But to really become a “baker” you need to be able to create your own recipes for each occasion. And to do that you actually need to “know what the hell you are talking about.” So 1.2 Class structures 1.2.1 Learning objective #1: Team based learning This course was designed to incorporate elements of Team Based Learning. This is an approach to creating permanent groups to work on problems in class and out of class throughout the semester. We are not going to follow the TBL approach strictly. But we are going to have fewer lectures and more structured group activities. Learn more about Team Based Learning by watching this video. 1.2.2 Learning objective #2: Show up ready Moving an increasing amount of teaching resources online is a big trend in education at all levels. But this isn’t just trendy, it appears to be very effective. Preliminary research shows that online learning paired with in-class interactions with faculty is a much more effective than the traditional lecture format. Watch this short TED talk by Peter Norvig to learn more: So in advance of each lecture 1.2.3 Learning objective #3: How is this going to work? The approach I am trying to adopt for this class is to help you learn in four basic steps. Initial exposure to materials through self-study. Repeated exposure to materials in short lectures. Use your new knowledge in a collaborative environment where assistance is readily available. Use your new knowledge on your own. The goal is for you to see and use information in multiple ways to improve learning outcomes. Experience (and research) shows that this approach is far superior to simple lectures in helping you learn more and retain it longer. To help you along this process, each learning component will be broken down as follows. You will read your book and review online materials. I will begin most classes with a short lecture where I will cover the materials again and answer questions. You will apply your knowledge during in-class team assignments. If you have any questions or run into problems, I will be right there to give you help. To keep the team motivated, these assignments will be graded. You will apply your knowledge on your own (or with friends) in your problem sets and final project. Machine learning and statistics is really just a subset of artificial intelligence (AI) research. For fun, just start telling people you are in an AI class and see how they react.↩︎ "],
["getting-started-in-r.html", "2 Getting Started in R 2.1 Learning Objectives 2.2 Assigning values to objects 2.3 R as a calculator 2.4 The global environment and how to clean it 2.5 Getting help 2.6 Installing packages", " 2 Getting Started in R 2.1 Learning Objectives Learn how to assign a value to an object in R. Learn your way around R (using R Studio). Learn how to do simple arithmetic in R. 2.2 Assigning values to objects You can assign values to objects in two ways as shown below. The assignment arrow is functionally equivalent to the equal sign. When assigning values to objects, R will always take the value on the right side of the assignment operator (&lt;- or =) and store it in the object on the left side of the assignment operator. This means that the two lines of commented code in the following snippet do different things. Side note: to comment a single line of code in R, use the hashtag or pound sign at the beginning of the line. If you’re working in an R script, the commented portion will turn green. x &lt;- 4 x ## [1] 4 y = 6 y ## [1] 6 #y = x #x = y It is best practice when coding to avoid “magic numbers” - i.e. all numbers should be stored in named variables so that if we want to change the value, we only have to do so once. This also removes any ambiguity for someone else reading your code who might wonder what the number represents. total.votes.ak &lt;- 238307 voting.age.population.ak &lt;- 496387 turnout.ak &lt;-total.votes.ak/voting.age.population.ak turnout.ak ## [1] 0.4800831 2.3 R as a calculator 5+4 # Addition ## [1] 9 6-3 # Subtraction ## [1] 3 34 / 6 # Division ## [1] 5.666667 5 * 3 # Multiplication ## [1] 15 5^4 # Exponents ## [1] 625 625^(1/4) # More exponents ## [1] 5 11%%2 # modular arithmetic (11 mod 2) is the remainder operator ## [1] 1 31 %/% 7 # The integer part of a fraction ## [1] 4 R comes with a number of constants prestored that you can use 6.25 # numbers pi # And a few others NA # Missing value NULL # Nothing. 0/0 # NaN means &quot;Not a number&quot; 1/0 # Inf means infinity R follows the order of operations (Please Excuse My Dear Aunt Sally). Side note - if you have multiple exponentiation, they execute right to left. 2*(3-4)+2 ## [1] 0 2*(3-4)+2*(4 + 3)^(1/3) ## [1] 1.825862 2.4 The global environment and how to clean it Named objects are stored in the “global environment”, which means that they can be accessed at any time by any function you might run. They are “global” variables which makes them different from “local” variables (variables that can only be accessed from within a certain scope like within a function). The commands ls() and rm() are used to show or remove variables from the global environment respectively. a &lt;- 1 b &lt;- 2 ls() ## [1] &quot;a&quot; &quot;b&quot; ## [3] &quot;collapse&quot; &quot;i&quot; ## [5] &quot;j&quot; &quot;m&quot; ## [7] &quot;mat1&quot; &quot;mat2&quot; ## [9] &quot;mat3&quot; &quot;matdf&quot; ## [11] &quot;matdf1&quot; &quot;matdf2&quot; ## [13] &quot;matrix1&quot; &quot;n&quot; ## [15] &quot;primaryPolls&quot; &quot;random_states&quot; ## [17] &quot;states10&quot; &quot;states100&quot; ## [19] &quot;total.votes.ak&quot; &quot;turnout.ak&quot; ## [21] &quot;voting.age.population.ak&quot; &quot;x&quot; ## [23] &quot;y&quot; &quot;ys&quot; rm(a) #this removes a from the global environment ls() ## [1] &quot;b&quot; &quot;collapse&quot; ## [3] &quot;i&quot; &quot;j&quot; ## [5] &quot;m&quot; &quot;mat1&quot; ## [7] &quot;mat2&quot; &quot;mat3&quot; ## [9] &quot;matdf&quot; &quot;matdf1&quot; ## [11] &quot;matdf2&quot; &quot;matrix1&quot; ## [13] &quot;n&quot; &quot;primaryPolls&quot; ## [15] &quot;random_states&quot; &quot;states10&quot; ## [17] &quot;states100&quot; &quot;total.votes.ak&quot; ## [19] &quot;turnout.ak&quot; &quot;voting.age.population.ak&quot; ## [21] &quot;x&quot; &quot;y&quot; ## [23] &quot;ys&quot; c &lt;- 3 rm(list = ls()) #this removes all global variables Some things are present in the working environment, but not shown in the global environment .x&lt;-&quot;Hide me&quot; print(.x) ## [1] &quot;Hide me&quot; ls() ## character(0) Anything that starts with a “.” will be accessible in your code, but hidden 2.5 Getting help Learning about functions and how to specify them correctly is half the battle help(sqrt) # help w/ functions ?sqrt # same thing help.start() # lots of help help.search(&quot;sqrt&quot;) # what am I looking for? Fuzzy matching example(sqrt) RSiteSearch(&quot;missing&quot;) TIPS: 1) Remember that these help menus are usually written by the same people who wrote the functions you are using. They are uniformly not helpful unless you already know a good bit about computer programming and (in some cases) a lot about the function itself. 2) There is a basic structure that all help files must meet, and it is very important that you try and get the hang of this. 2.6 Installing packages The beauty of R is that there are packages, although things can be a bit unorganized. install.packages(&quot;BAS&quot;) # This will prompt a user interface to choose the &quot;mirror&quot; or repository library(BAS) # this will actually load the library for use. You must call this every time. search() # you can see what packages are attached to the workspace (and also what other objects) help(package=&quot;BAS&quot;) # Will (usually) give you a list of functions for the package example(BAS) # some package writers give you little examples to get you started All packages documentation are on CRAN Many packages come with example datasets built in data() data(rock) ?rock # there are help files for these ls() # there&#39;s rock -- in the global environment data(road, package=&quot;MASS&quot;) # you can load these datasets without loading the package "],
["data-types-in-r.html", "3 Data Types in R 3.1 Functions 3.2 Vectors 3.3 Functions and vectors 3.4 Logicals/Booleans 3.5 Characters/Strings 3.6 Matrices 3.7 Matrix algebra (optional) 3.8 Lists 3.9 Arrays 3.10 Dataframes 3.11 General info", " 3 Data Types in R 3.1 Functions log ## function (x, base = exp(1)) .Primitive(&quot;log&quot;) log(2) # ln(2) ## [1] 0.6931472 log(2, base=10) # log(2) base 10 ## [1] 0.30103 log(base = 10, x = 2) ## [1] 0.30103 exp(log(1)) # e^ln(1) = 1 ## [1] 1 3.2 Vectors The c() function is used to collect/concatenate things together into a vector c(0,7,8) ## [1] 0 7 8 x&lt;-c(0,7,8) # assign this to a named object An easy way to make a sequence vector is using the : operator. numbers5to20 &lt;- 5:20 # numbers5to20 ## [1] 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Note that it always increments by 1 1.5:10 ## [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 You can also concatenate any two vectors to make a new vector c(numbers5to20, x) ## [1] 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0 7 8 3.3 Functions and vectors Many functions have been “Vectorized” meaning that they work on each element in the vector numbers5to20*2 ## [1] 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 sqrt(numbers5to20) ## [1] 2.236068 2.449490 2.645751 2.828427 3.000000 3.162278 3.316625 3.464102 ## [9] 3.605551 3.741657 3.872983 4.000000 4.123106 4.242641 4.358899 4.472136 log(numbers5to20) ## [1] 1.609438 1.791759 1.945910 2.079442 2.197225 2.302585 2.397895 2.484907 ## [9] 2.564949 2.639057 2.708050 2.772589 2.833213 2.890372 2.944439 2.995732 abs(numbers5to20) ## [1] 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 numbers5to20^2 ## [1] 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 But when you “Interact” two vectors, they will work “elementwise” numbers5to20*numbers5to20 ## [1] 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 numbers5to20+numbers5to20 ## [1] 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 numbers5to20+rev(numbers5to20) ## [1] 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 25 data &lt;- c(NA, 4, 7, NA, 19) is.na(data) #tells us true or false whether each value is NA ## [1] TRUE FALSE FALSE TRUE FALSE !is.na(data) #true if the value is *not* NA ## [1] FALSE TRUE TRUE FALSE TRUE Other functions operate on a functions work more directly sum(numbers5to20) ## [1] 200 prod(numbers5to20) #multiples all elements together ## [1] 1.013709e+17 mean(numbers5to20) ## [1] 12.5 var(numbers5to20) ## [1] 22.66667 max(numbers5to20, na.rm=T) # maximum -- ignore missing data ## [1] 20 min(numbers5to20, na.rm=TRUE) #minimum -- notice that T=TRUE ## [1] 5 summary(numbers5to20) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 5.00 8.75 12.50 12.50 16.25 20.00 Accessing elements of a vector or matrix is usually done with the [] operators We can access the first or fortieth element of vap. numbers5to20[1] ## [1] 5 numbers5to20[40] ## [1] NA We can also extract several elements at a time using vectors. numbers5to20[c(3,6,7)] ## [1] 7 10 11 numbers5to20[3:7] ## [1] 7 8 9 10 11 We can repeat numbers as well numbers5to20[c(3,3,2,2)] ## [1] 7 7 6 6 This code prints everything but the 4th through 7th elements by using the negative sign numbers5to20[-(4:7)] ## [1] 5 6 7 12 13 14 15 16 17 18 19 20 x x*3 #scalar multiplication y&lt;-x-5 #simple addition and multiplicaiton are done &quot;by element&quot; y x^3 # ditto with exponents y^x # but if each are three elements long, it will execute by element Vector recycling When vectors have different lengths, the shorter one is extended by repeating the vector. This means two things: 1. The vector lengths must be multiples of each other 2. This is a very easy way to make a bad, bad mistake. You can easily find the length of a vector length(numbers5to20) ## [1] 16 Other functions will create vectors as outputs rep(1, 5) #Repeat the value 1, 5 times ## [1] 1 1 1 1 1 seq(1, 21, by=2) #Make the sequence 1 to 21 moving by increments of 2 ## [1] 1 3 5 7 9 11 13 15 17 19 21 rep(seq(2,20, by=2), 2) #Repeat the pattern 2, 4, ... 20, twice ## [1] 2 4 6 8 10 12 14 16 18 20 2 4 6 8 10 12 14 16 18 20 rep(c(1,4), c(3,2)) #Repeat 1, 3 times and 4, twice ## [1] 1 1 1 4 4 rep(c(1,4), each=3) #Repeat each value 3 times ## [1] 1 1 1 4 4 4 3.4 Logicals/Booleans Logicals are often used when subsetting or recoding data Generally necessary to understand this for data wrangling x&lt;-c(0, 7, 8) chooser&lt;-c(T, F, T) x[chooser] # print ony those elements of x where chooser is TRUE ## [1] 0 8 Arithmetic operations on logicals create numerics where: TRUE is treated as a ‘1’, and FALSE is treated as a ‘0’ sum(chooser) # Number of true values ## [1] 2 3.4.1 Boolean logic x == 7 #equals ## [1] FALSE TRUE FALSE x != 7 #does not equal ## [1] TRUE FALSE TRUE x &gt; 7 #greater than ## [1] FALSE FALSE TRUE x &gt;= 7 #greater than or equal to ## [1] FALSE TRUE TRUE x &lt; 7 #less than ## [1] TRUE FALSE FALSE x &lt;= 7 #less than or equal to ## [1] TRUE TRUE FALSE x &lt; 7 | x == 7 ## the or operator ## [1] TRUE TRUE FALSE x &lt;= 7 &amp; x == 7 ## the and operator ## [1] FALSE TRUE FALSE “or” - the pipe symbol - returns true if either/any of the conditions are true “and” - the ampersand - returns true if both/all of the conditions are true Most of the time, we use boolean logic to subset datasets. Here’s some data to get us started vap&lt;-voting.age.population&lt;-c(3481823, 496387, 4582842, 2120139,26955438, 3617942,2673154,652189,472143,14085749,6915512, 995937,1073799,9600372,4732010,2265860,2068253, 3213141,3188765,1033632,4242214,4997677,7620982, 3908159,2139918,4426278,731365,1321923,1870315,1012033, 6598368,1452962,14838076,6752018,494923,8697456,2697855, 2850525,9612380,824854,3303593,594599,4636679, 17038979,1797941,487900,5841335,4876661,1421717, 4257230,392344) total.votes&lt;-tv&lt;-c(NA, 238307, 1553032, 780409,8899059,1586105, 1162391,258053, 122356,4884544, 2143845,348988, 458927,3586292, 1719351,1071509, 864083,1370062, 954896,NA, 1809237, 2243835,3852008, 2217552,NA, 2178278, 411061,610499, 586274,418550, 2315643,568597, 4703830,2036451, 220479,4184072, NA,1399650, NA,392882, 1117311,341105, 1868363,NA, 582561, 263025,2398589, 2085074,473014, 2183155, 196217) tv[!is.na(tv)] #get all valid datapoints from the tv dataset ## [1] 238307 1553032 780409 8899059 1586105 1162391 258053 122356 4884544 ## [10] 2143845 348988 458927 3586292 1719351 1071509 864083 1370062 954896 ## [19] 1809237 2243835 3852008 2217552 2178278 411061 610499 586274 418550 ## [28] 2315643 568597 4703830 2036451 220479 4184072 1399650 392882 1117311 ## [37] 341105 1868363 582561 263025 2398589 2085074 473014 2183155 196217 small.states&lt;- voting.age.population[voting.age.population &lt; median(voting.age.population)] small.states ## [1] 496387 2120139 2673154 652189 472143 995937 1073799 2265860 2068253 ## [10] 1033632 2139918 731365 1321923 1870315 1012033 1452962 494923 2697855 ## [19] 2850525 824854 594599 1797941 487900 1421717 392344 state.size&lt;-(voting.age.population &gt; median(voting.age.population)) *1 state.size #this code makes a new vector equal to 1 if it&#39;s a large state (larger than median), 0 otherwise ## [1] 1 0 1 0 1 1 0 0 0 1 1 0 0 1 1 0 0 1 0 0 1 1 1 1 0 1 0 0 0 0 1 0 1 1 0 1 0 0 ## [39] 1 0 1 0 1 1 0 0 1 1 0 1 0 which(state.size == 1) #returns the vector of indices of the elements that have state.size equal to 1 ## [1] 1 3 5 6 10 11 14 15 18 21 22 23 24 26 31 33 34 36 39 41 43 44 47 48 50 any(x&gt;2) #returns true if the condition is true for any element ## [1] TRUE all(x&gt;2) #returns true if the condition is true for all elements ## [1] FALSE 3.5 Characters/Strings colors &lt;- c(&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;magenta&quot;, &quot;cyan&quot;) You might want only a portion of the string. substr(colors, start=1, stop=2) ## [1] &quot;re&quot; &quot;ye&quot; &quot;bl&quot; &quot;gr&quot; &quot;ma&quot; &quot;cy&quot; paste0(colors, &quot;flowers&quot;) # combine two strings ## [1] &quot;redflowers&quot; &quot;yellowflowers&quot; &quot;blueflowers&quot; &quot;greenflowers&quot; ## [5] &quot;magentaflowers&quot; &quot;cyanflowers&quot; paste(colors, &quot;flowers&quot;, sep=&quot;&quot;) # combine two strings ## [1] &quot;redflowers&quot; &quot;yellowflowers&quot; &quot;blueflowers&quot; &quot;greenflowers&quot; ## [5] &quot;magentaflowers&quot; &quot;cyanflowers&quot; paste(&quot;I like&quot;, colors, &quot;flowers&quot;) ## [1] &quot;I like red flowers&quot; &quot;I like yellow flowers&quot; &quot;I like blue flowers&quot; ## [4] &quot;I like green flowers&quot; &quot;I like magenta flowers&quot; &quot;I like cyan flowers&quot; paste(&quot;I like&quot;, colors, &quot;flowers&quot;, collapse = &quot;&quot;) ## [1] &quot;I like red flowersI like yellow flowersI like blue flowersI like green flowersI like magenta flowersI like cyan flowers&quot; nchar(colors) #how many characters in each string ## [1] 3 6 4 5 7 4 You may want to divide a string into components extreme.statement&lt;-&quot;Coding is my life&quot; this.out&lt;-strsplit(extreme.statement, split=&quot; &quot;) unlist(this.out) ## [1] &quot;Coding&quot; &quot;is&quot; &quot;my&quot; &quot;life&quot; Use gsub to replace or remove parts of a string gsub(&quot;my life&quot;, &quot;the bee&#39;s knees&quot;, extreme.statement) ## [1] &quot;Coding is the bee&#39;s knees&quot; # less extreme. More true gsub(&quot; is my life&quot;, &quot;&quot;, extreme.statement) ## [1] &quot;Coding&quot; Tips for using strings: If you are doing a lot with strings try the library ‘strgr’, which has some user-friendly functions If you include ‘’ in a string, in many instances it will be a carriage return (e.g., plotting) A very common programming error is to forget a closing quotation mark. This will make the computer think you are still making a giantly long string. 3.6 Matrices A matrix is just a collection of vectors You can combine vectors by column using ‘cbind’ m1 &lt;- cbind(vap, tv) head(m1) ## vap tv ## [1,] 3481823 NA ## [2,] 496387 238307 ## [3,] 4582842 1553032 ## [4,] 2120139 780409 ## [5,] 26955438 8899059 ## [6,] 3617942 1586105 Or you can combine by rows using ‘rbind’ m2 &lt;- rbind(vap, tv) head(m2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## vap 3481823 496387 4582842 2120139 26955438 3617942 2673154 652189 472143 ## tv NA 238307 1553032 780409 8899059 1586105 1162391 258053 122356 ## [,10] [,11] [,12] [,13] [,14] [,15] [,16] [,17] [,18] ## vap 14085749 6915512 995937 1073799 9600372 4732010 2265860 2068253 3213141 ## tv 4884544 2143845 348988 458927 3586292 1719351 1071509 864083 1370062 ## [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] [,27] ## vap 3188765 1033632 4242214 4997677 7620982 3908159 2139918 4426278 731365 ## tv 954896 NA 1809237 2243835 3852008 2217552 NA 2178278 411061 ## [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] ## vap 1321923 1870315 1012033 6598368 1452962 14838076 6752018 494923 8697456 ## tv 610499 586274 418550 2315643 568597 4703830 2036451 220479 4184072 ## [,37] [,38] [,39] [,40] [,41] [,42] [,43] [,44] [,45] ## vap 2697855 2850525 9612380 824854 3303593 594599 4636679 17038979 1797941 ## tv NA 1399650 NA 392882 1117311 341105 1868363 NA 582561 ## [,46] [,47] [,48] [,49] [,50] [,51] ## vap 487900 5841335 4876661 1421717 4257230 392344 ## tv 263025 2398589 2085074 473014 2183155 196217 We can access by ‘matrixname[row, column]’ m2[1,2] # first row, second column ## vap ## 496387 m1[,1] # the 1st column ## [1] 3481823 496387 4582842 2120139 26955438 3617942 2673154 652189 ## [9] 472143 14085749 6915512 995937 1073799 9600372 4732010 2265860 ## [17] 2068253 3213141 3188765 1033632 4242214 4997677 7620982 3908159 ## [25] 2139918 4426278 731365 1321923 1870315 1012033 6598368 1452962 ## [33] 14838076 6752018 494923 8697456 2697855 2850525 9612380 824854 ## [41] 3303593 594599 4636679 17038979 1797941 487900 5841335 4876661 ## [49] 1421717 4257230 392344 Can get a submatrix m1[1:5,1:2] ## vap tv ## [1,] 3481823 NA ## [2,] 496387 238307 ## [3,] 4582842 1553032 ## [4,] 2120139 780409 ## [5,] 26955438 8899059 m2[1,1:10] ## [1] 3481823 496387 4582842 2120139 26955438 3617942 2673154 652189 ## [9] 472143 14085749 m2[1,1:10] ## [1] 3481823 496387 4582842 2120139 26955438 3617942 2673154 652189 ## [9] 472143 14085749 m2[1:2, 1:10] ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## vap 3481823 496387 4582842 2120139 26955438 3617942 2673154 652189 472143 ## tv NA 238307 1553032 780409 8899059 1586105 1162391 258053 122356 ## [,10] ## vap 14085749 ## tv 4884544 m2[, 1:10] # same as previous line since there are only two rows. ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## vap 3481823 496387 4582842 2120139 26955438 3617942 2673154 652189 472143 ## tv NA 238307 1553032 780409 8899059 1586105 1162391 258053 122356 ## [,10] ## vap 14085749 ## tv 4884544 class(m2) ## [1] &quot;matrix&quot; Objects in R are simply pieces of data that contain specific attributes. Classes define what attributes an object must have and can have. Matrices always have an attribute that determines the number of rows and columns dim(m1) ## [1] 51 2 For any object you can look at it’s attributes using (helpfully) the ‘attributes’ function attributes(m1) ## $dim ## [1] 51 2 ## ## $dimnames ## $dimnames[[1]] ## NULL ## ## $dimnames[[2]] ## [1] &quot;vap&quot; &quot;tv&quot; We see that the matrix also has another attribute dimnames(m1) ## [[1]] ## NULL ## ## [[2]] ## [1] &quot;vap&quot; &quot;tv&quot; The top refers to the row names (which do not exist) The bottom are the column names (that were borrowed from the vectors used to construct the matrix). You can also access these using functions colnames(m1) ## [1] &quot;vap&quot; &quot;tv&quot; colnames(m2) ## NULL rownames(m1) ## NULL rownames(m2) ## [1] &quot;vap&quot; &quot;tv&quot; And you can reset these using the same functions colnames(m1)&lt;-c(&quot;Voting age population&quot;, &quot;Total Votes&quot;) colnames(m1) ## [1] &quot;Voting age population&quot; &quot;Total Votes&quot; You can also do this with the following dimnames(m1)[[2]][1]&lt;-&quot;Pigglywiggly&quot; head(m1) ## Pigglywiggly Total Votes ## [1,] 3481823 NA ## [2,] 496387 238307 ## [3,] 4582842 1553032 ## [4,] 2120139 780409 ## [5,] 26955438 8899059 ## [6,] 3617942 1586105 We have re-named the first column to have the name “Pigglywiggly” We are able to do this because the output of ‘dimnames’ is a list You can subset matrices with a boolean/logical matrix to get certain values from it just like you would a vector Matrices (and vectors) can only contain one datatype If you try to create one with multiple datatypes, it will convert everything to be the same datatype 3.7 Matrix algebra (optional) A couple of matrices H3&lt;-matrix(c(1, 1/2, 1/3, 1/2, 1/3, 1/4, 1/3, 1/4, 1/5), nrow=3) H3 ## [,1] [,2] [,3] ## [1,] 1.0000000 0.5000000 0.3333333 ## [2,] 0.5000000 0.3333333 0.2500000 ## [3,] 0.3333333 0.2500000 0.2000000 1/cbind(seq(1,3), seq(2, 4), seq(3,5)) # most basic function continue to be &quot;element wise&quot; ## [,1] [,2] [,3] ## [1,] 1.0000000 0.5000000 0.3333333 ## [2,] 0.5000000 0.3333333 0.2500000 ## [3,] 0.3333333 0.2500000 0.2000000 H3+1 ## [,1] [,2] [,3] ## [1,] 2.000000 1.500000 1.333333 ## [2,] 1.500000 1.333333 1.250000 ## [3,] 1.333333 1.250000 1.200000 H3*2 ## [,1] [,2] [,3] ## [1,] 2.0000000 1.0000000 0.6666667 ## [2,] 1.0000000 0.6666667 0.5000000 ## [3,] 0.6666667 0.5000000 0.4000000 H3^2 ## [,1] [,2] [,3] ## [1,] 1.0000000 0.2500000 0.1111111 ## [2,] 0.2500000 0.1111111 0.0625000 ## [3,] 0.1111111 0.0625000 0.0400000 mean(H3) # others will treat the matrix as a vector no matter what ## [1] 0.4111111 rowSums(H3) # others work on matrices in particular ways (more on this later) ## [1] 1.8333333 1.0833333 0.7833333 colSums(H3) ## [1] 1.8333333 1.0833333 0.7833333 rowMeans(H3) ## [1] 0.6111111 0.3611111 0.2611111 colMeans(H3) ## [1] 0.6111111 0.3611111 0.2611111 Logicals work too H3 == 1 ## [,1] [,2] [,3] ## [1,] TRUE FALSE FALSE ## [2,] FALSE FALSE FALSE ## [3,] FALSE FALSE FALSE H3 == c(1,2,3) # wha...? ## [,1] [,2] [,3] ## [1,] TRUE FALSE FALSE ## [2,] FALSE FALSE FALSE ## [3,] FALSE FALSE FALSE H3 == H3 ## [,1] [,2] [,3] ## [1,] TRUE TRUE TRUE ## [2,] TRUE TRUE TRUE ## [3,] TRUE TRUE TRUE Some work like they do in the math books det(H3) # the determinant -- hard for you ... easy in R ## [1] 0.000462963 diag(H3) # get the diagonal elements of amatrix ## [1] 1.0000000 0.3333333 0.2000000 diag(1, nrow=3) # make a 3by3 identity matrix ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 t(H3) # matrix transpose ## [,1] [,2] [,3] ## [1,] 1.0000000 0.5000000 0.3333333 ## [2,] 0.5000000 0.3333333 0.2500000 ## [3,] 0.3333333 0.2500000 0.2000000 Hnew&lt;-H3 Hnew[lower.tri(H3, diag=TRUE)] # extract the lower triangular elements of H3 ## [1] 1.0000000 0.5000000 0.3333333 0.3333333 0.2500000 0.2000000 # Get the trace trace &lt;- function(data) (sum(diag(data))) # our own little function .. more on this next time trace(H3) ## [1] 1.533333 # Matrix multipication is %*% t(H3)%*%H3 ## [,1] [,2] [,3] ## [1,] 1.361111 0.7500000 0.5250000 ## [2,] 0.750000 0.4236111 0.3000000 ## [3,] 0.525000 0.3000000 0.2136111 c(1,2,3)%*%c(1,2,3) # dot product ## [,1] ## [1,] 14 matrix(c(1,2,3), ncol=1)%*%c(1,2,3) # outer product ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 2 4 6 ## [3,] 3 6 9 #matrix inversion solve(H3) ## [,1] [,2] [,3] ## [1,] 9 -36 30 ## [2,] -36 192 -180 ## [3,] 30 -180 180 invH3&lt;-solve(H3) H3%*%invH3 ## close enough? ## [,1] [,2] [,3] ## [1,] 1.000000e+00 0.000000e+00 0 ## [2,] 8.881784e-16 1.000000e+00 0 ## [3,] 0.000000e+00 -7.105427e-15 1 # Why is it called solve? It can also be used to solve linear systems. b&lt;-c(1,2,3) b ## [1] 1 2 3 solve(H3, b) ## [1] 27 -192 210 3.8 Lists Let’s make a list that contains a matrix, a vector, and an integer. list.a&lt;-list(m1, vap, 3) str(list.a) ## List of 3 ## $ : num [1:51, 1:2] 3481823 496387 4582842 2120139 26955438 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:2] &quot;Pigglywiggly&quot; &quot;Total Votes&quot; ## $ : num [1:51] 3481823 496387 4582842 2120139 26955438 ... ## $ : num 3 This is the advantage of lists. They can contain basically anything, even other lists vector1&lt;-c(1,2,3) gospels&lt;-c(&quot;matthew&quot;,&quot;mark&quot;,&quot;luke&quot;, &quot;john&quot;) my.matrix&lt;-matrix(c(1:20), nrow=4) my.data&lt;-data.frame(cbind(vap, tv)) my.crazy.list&lt;-list(vector1, gospels, my.matrix, TRUE, list.a) str(my.crazy.list) ## List of 5 ## $ : num [1:3] 1 2 3 ## $ : chr [1:4] &quot;matthew&quot; &quot;mark&quot; &quot;luke&quot; &quot;john&quot; ## $ : int [1:4, 1:5] 1 2 3 4 5 6 7 8 9 10 ... ## $ : logi TRUE ## $ :List of 3 ## ..$ : num [1:51, 1:2] 3481823 496387 4582842 2120139 26955438 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;Pigglywiggly&quot; &quot;Total Votes&quot; ## ..$ : num [1:51] 3481823 496387 4582842 2120139 26955438 ... ## ..$ : num 3 Lists have attributes but we haven’t set them yet attributes(my.crazy.list) ## NULL This reports the number of major sub-elements in the list. length(my.crazy.list) ## [1] 5 This won’t work for complicated lists dim(my.crazy.list) ## NULL We can give names to elements of a list names(my.crazy.list)&lt;-c(&quot;OneTwoThree&quot;, &quot;Gospels&quot;, &quot;SmallMat&quot;, &quot;OneLogical&quot;, &quot;AnotherList&quot;) str(my.crazy.list) ## List of 5 ## $ OneTwoThree: num [1:3] 1 2 3 ## $ Gospels : chr [1:4] &quot;matthew&quot; &quot;mark&quot; &quot;luke&quot; &quot;john&quot; ## $ SmallMat : int [1:4, 1:5] 1 2 3 4 5 6 7 8 9 10 ... ## $ OneLogical : logi TRUE ## $ AnotherList:List of 3 ## ..$ : num [1:51, 1:2] 3481823 496387 4582842 2120139 26955438 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;Pigglywiggly&quot; &quot;Total Votes&quot; ## ..$ : num [1:51] 3481823 496387 4582842 2120139 26955438 ... ## ..$ : num 3 Now each part of the list has a name attribute Skip the steps above by doing the following: my.crazy.list&lt;-list(OneTwoThree=vector1, Gospels=gospels, SmallMat=my.matrix, OneLogical=TRUE, AnotherList=list.a) str(my.crazy.list) ## List of 5 ## $ OneTwoThree: num [1:3] 1 2 3 ## $ Gospels : chr [1:4] &quot;matthew&quot; &quot;mark&quot; &quot;luke&quot; &quot;john&quot; ## $ SmallMat : int [1:4, 1:5] 1 2 3 4 5 6 7 8 9 10 ... ## $ OneLogical : logi TRUE ## $ AnotherList:List of 3 ## ..$ : num [1:51, 1:2] 3481823 496387 4582842 2120139 26955438 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;Pigglywiggly&quot; &quot;Total Votes&quot; ## ..$ : num [1:51] 3481823 496387 4582842 2120139 26955438 ... ## ..$ : num 3 names(my.crazy.list) ## [1] &quot;OneTwoThree&quot; &quot;Gospels&quot; &quot;SmallMat&quot; &quot;OneLogical&quot; &quot;AnotherList&quot; There are at least four ways of accessing elements of a list my.crazy.list[[1]] ## [1] 1 2 3 my.crazy.list$OneTwoThree ## [1] 1 2 3 my.crazy.list[1] ## $OneTwoThree ## [1] 1 2 3 my.crazy.list[&quot;OneTwoThree&quot;] ## $OneTwoThree ## [1] 1 2 3 You can add elements in a similarly confusing number of ways my.crazy.list$hocuspocus&lt;-&quot;hocuspocus&quot; str(my.crazy.list) ## List of 6 ## $ OneTwoThree: num [1:3] 1 2 3 ## $ Gospels : chr [1:4] &quot;matthew&quot; &quot;mark&quot; &quot;luke&quot; &quot;john&quot; ## $ SmallMat : int [1:4, 1:5] 1 2 3 4 5 6 7 8 9 10 ... ## $ OneLogical : logi TRUE ## $ AnotherList:List of 3 ## ..$ : num [1:51, 1:2] 3481823 496387 4582842 2120139 26955438 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;Pigglywiggly&quot; &quot;Total Votes&quot; ## ..$ : num [1:51] 3481823 496387 4582842 2120139 26955438 ... ## ..$ : num 3 ## $ hocuspocus : chr &quot;hocuspocus&quot; You can also access access/add to/subtract from the sub-elements themselves. We just add what we know about accessing elements of matrices/vectors/etc. to how we access lists. my.crazy.list[[3]][1,] # first row of my.matrix ## [1] 1 5 9 13 17 my.matrix[1,] #the same ## [1] 1 5 9 13 17 But lists don’t play well with basic commands. Only components of lists. #this won&#39;t work #my.crazy.list + 2 #but this will! my.crazy.list[[3]] + 2 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 3 7 11 15 19 ## [2,] 4 8 12 16 20 ## [3,] 5 9 13 17 21 ## [4,] 6 10 14 18 22 3.9 Arrays Arrays are effectively matrices that can have more than 2 dimensions. An array with exactly two dimensions is a matrix. The following example creates an array of two 3x4 matrices each with 3 rows and 4 columns. # Take the sequence from 1 to 24 as input to the array. result &lt;- array(1:24, dim=c(3,4,2)) result ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 13 16 19 22 ## [2,] 14 17 20 23 ## [3,] 15 18 21 24 # You can also name all of the dimensions. column.names &lt;- c(&quot;COL1&quot;,&quot;COL2&quot;,&quot;COL3&quot;,&quot;COL4&quot;) row.names &lt;- c(&quot;ROW1&quot;,&quot;ROW2&quot;,&quot;ROW3&quot;) matrix.names &lt;- c(&quot;Matrix1&quot;,&quot;Matrix2&quot;) result2 &lt;- array(1:24, dim=c(3,4,2), dimnames=list(row.names, column.names, matrix.names)) result2 ## , , Matrix1 ## ## COL1 COL2 COL3 COL4 ## ROW1 1 4 7 10 ## ROW2 2 5 8 11 ## ROW3 3 6 9 12 ## ## , , Matrix2 ## ## COL1 COL2 COL3 COL4 ## ROW1 13 16 19 22 ## ROW2 14 17 20 23 ## ROW3 15 18 21 24 # Print the third row of the second matrix of the array. result[3,,2] ## [1] 15 18 21 24 # Print the element in the 1st row and 3rd column of the 1st matrix. result[1,3,1] ## [1] 7 # Print the 2nd Matrix. result[,,2] ## [,1] [,2] [,3] [,4] ## [1,] 13 16 19 22 ## [2,] 14 17 20 23 ## [3,] 15 18 21 24 3.10 Dataframes They are rectangular like a matrix, but each column can be of a different class and you can access elements of the data frame like it’s a list. turnout &lt;- tv/vap voting.data &lt;- data.frame(tv, vap, turnout) head(voting.data) ## tv vap turnout ## 1 NA 3481823 NA ## 2 238307 496387 0.4800831 ## 3 1553032 4582842 0.3388797 ## 4 780409 2120139 0.3680933 ## 5 8899059 26955438 0.3301397 ## 6 1586105 3617942 0.4383998 str(voting.data) ## &#39;data.frame&#39;: 51 obs. of 3 variables: ## $ tv : num NA 238307 1553032 780409 8899059 ... ## $ vap : num 3481823 496387 4582842 2120139 26955438 ... ## $ turnout: num NA 0.48 0.339 0.368 0.33 ... There are at least four ways to access a variable head(voting.data[[1]]) ## [1] NA 238307 1553032 780409 8899059 1586105 head(voting.data$tv) ## [1] NA 238307 1553032 780409 8899059 1586105 head(voting.data[&quot;tv&quot;]) ## tv ## 1 NA ## 2 238307 ## 3 1553032 ## 4 780409 ## 5 8899059 ## 6 1586105 head(voting.data[,1]) ## [1] NA 238307 1553032 780409 8899059 1586105 names(voting.data) #access the column names ## [1] &quot;tv&quot; &quot;vap&quot; &quot;turnout&quot; # NOTE: dataframes always have column names!! colnames(voting.data) ## [1] &quot;tv&quot; &quot;vap&quot; &quot;turnout&quot; We can change back and forth between a matrix and a data frame as.data.frame(my.matrix) ## V1 V2 V3 V4 V5 ## 1 1 5 9 13 17 ## 2 2 6 10 14 18 ## 3 3 7 11 15 19 ## 4 4 8 12 16 20 data.frame(my.matrix) ## X1 X2 X3 X4 X5 ## 1 1 5 9 13 17 ## 2 2 6 10 14 18 ## 3 3 7 11 15 19 ## 4 4 8 12 16 20 head(as.matrix(voting.data)) ## tv vap turnout ## [1,] NA 3481823 NA ## [2,] 238307 496387 0.4800831 ## [3,] 1553032 4582842 0.3388797 ## [4,] 780409 2120139 0.3680933 ## [5,] 8899059 26955438 0.3301397 ## [6,] 1586105 3617942 0.4383998 Sometimes all of this can be a bit cumbersome The ‘with’ command will run a function with the dataset slightly easier # these are equivalent mean(voting.data$vap) ## [1] 4430673 with(voting.data, mean(vap)) ## [1] 4430673 3.11 General info You can determine the type of a variable by calling class on it as follows class(vap) ## [1] &quot;numeric&quot; There are functions to move back and forth between types (‘as.class’ functions) grp &lt;- c(&quot;control&quot;, &quot;treatment&quot;, &quot;control&quot;, &quot;treatment&quot;) grp &lt;- factor(grp) as.integer(grp) ## [1] 1 2 1 2 You can also check if an object is a specific class. is.integer(vap) ## [1] FALSE is.numeric(vap) ## [1] TRUE There are several types of these as.character(0:5) # Turning numbers into characters ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; as.logical(0:5) # All numbers but &#39;0&#39; become TRUE ## [1] FALSE TRUE TRUE TRUE TRUE TRUE But not all of them work as.numeric(c(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)) ## [1] 1 2 3 as.numeric(c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)) ## Warning: NAs introduced by coercion ## [1] NA NA NA "],
["files-for-loops-and-functions.html", "4 Files, For Loops, and Functions 4.1 The working directory 4.2 Input and output 4.3 if, else, ifelse 4.4 repeat and while 4.5 for loops 4.6 Functions 4.7 Setting defaults 4.8 Scope 4.9 Debugging 4.10 Benchmarking and code improvements", " 4 Files, For Loops, and Functions 4.1 The working directory First we want to change the working directory. This is the folder where R will save and look for data by default (although you can always override this) Note that the file path (in Windows at least) requires slashes. You can either use two back slashes to separate folders or one forward slash. setwd(&quot;~/Dropbox/Classes/R Programming&quot;) ## For Windows, will need to be something like setwd(&quot;C:\\\\Documents and Settings\\\\Jacob Montgomery\\\\My Documents\\\\RWork&quot;) ## or setwd(&quot;C:/Documents and Settings/Jacob Montgomery/My Documents/RWork&quot;) ## or setwd(file.path(&quot;C:&quot;, &quot;Documents and Settings&quot;, &quot;Jacob Montgomery&quot;, &quot;My Documents&quot;, &quot;RWork&quot;)) 4.2 Input and output voting.data&lt;-data.frame(vap, tv) Now let’s save our newly created dataset dump(&quot;voting.data&quot;, &quot;voting.data.R&quot;) # inputs are string. Note that you must put the *.R in yourself You might also want to save multiple objects dump(c(&quot;vap&quot;, &quot;tv&quot;), &quot;voting.data.vectors.R&quot;) dump(list=objects(), &quot;everything.R&quot;) ## an alternative we can just use the command save.image(&quot;everything.RData&quot;) # saves an image of your current workspace Now we can clear our wokspace, and load these objects rm(list=ls()) source(&quot;voting.data.vectors.R&quot;) ls() # only saved objects present To read/write dataframes from/to a csv (comma separated values) file, the following commands will be useful votes.06&lt;-read.csv(&quot;~/Dropbox/Classes/R Programming/R Scripts/VotingData2006.csv&quot;, header=T) write.csv(votes.06, file=&quot;VD06.csv&quot;) Tips: All of the functions for reading in data are actually using the scan() function. No matter how crazy your data look, you can always read it into R by clever use of scan(). 4.3 if, else, ifelse The basic syntax for an if call is if(condition){ commands to run } The inputs in the parentheses needs can be anything that returns a logical. You can put anything you want in the braces The simplest examples possible. if(TRUE) { print(&quot;I got here&quot;) } ## [1] &quot;I got here&quot; if(FALSE){ print(&quot;I can&#39;t get here&quot;) } You can combine this with else if(condition) { commands to run when condition is TRUE } else { # notice that these are on the same line commands to run when the condition is FALSE } x = 10 if(x &gt; 2) { print(&quot;X is larger than 2&quot;) } else { print(&quot;X is 2 or smaller&quot;) } ## [1] &quot;X is larger than 2&quot; But this set up will not play well with vectors. It runs, but is confusing if (c(3, 1) &gt; 2){ print(&quot;This won&#39;t work&quot;) } ## Warning in if (c(3, 1) &gt; 2) {: the condition has length &gt; 1 and only the first ## element will be used ## [1] &quot;This won&#39;t work&quot; The ifelse command works nicely with vectors, but syntax is different. This command is equivalent to a ternary in other languages if you’re familiar with that term. ifelse(condition, return when condition T, return when condition F) x = c(0, 2) ifelse(x &gt; 1, &quot;yes&quot;, &quot;no&quot;) ## [1] &quot;no&quot; &quot;yes&quot; WARNING If your outputs are vectors ifelse will work element-wise yes = c(&quot;yes1&quot;, &quot;yes2&quot;) no = c(&quot;no1&quot;, &quot;no2&quot;) ifelse(x &gt; 1, yes, no) ## [1] &quot;no1&quot; &quot;yes2&quot; ifelse(x &lt; 2, yes, no) ## [1] &quot;yes1&quot; &quot;no2&quot; Note that the curly braces are not technically necessary if you have only a one line command BUT you should use them anyway so someone can read your code! x = 3 if (x &gt; 2) y = 2 * x else y = 3 * x y ## [1] 6 4.4 repeat and while Repeat just repeats commands in the braces until it sees a BREAK command If you don’t include BREAK your computer will be in an infinite loop. Save your work before using! Or maybe just don’t use it repeat{ stuff to do until it sees BREAK } # make a blank plot with the limits set by those vectors plot(NULL, xlim=c(0, 100), ylim=c(0, 1), xlab=&quot;x&quot;, ylab=&quot;1/x&quot;) x = 1 repeat { y = 1 / x x = x + 1 points(x, y) if (x == 100) { break } } A while loop is just a repeat, where the break condition is specified at the top while(condition){ commands that repeat until condition flips to FALSE } plot(NULL, xlim=c(0, 100), ylim=c(0, 1), xlab=&quot;x&quot;, ylab=&quot;1/x&quot;) x = 1 while(x &lt; 100) { y = 1 / x x = x + 1 points(x, y) } 4.5 for loops The for command is probably the most common flow control option. It has three basic parts: An object name that will be used in the following commands A vector that we will “loop over” Commands that will be executed for each value of the vector for (name in vector){ execute these commands using each value of the vecotr } for (monkey in c(&quot;Spider&quot;, &quot;Howler&quot;, &quot;Rhesus&quot;)) { ## Each loop does the equivalent of: monkey = &quot;Spider&quot; or monkey = &quot;Howler&quot; or ... print(monkey) } ## [1] &quot;Spider&quot; ## [1] &quot;Howler&quot; ## [1] &quot;Rhesus&quot; Or more commonly for (i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## for loops are very useful in many situations plot(NULL, xlim=c(0, 100), ylim=c(0, 1)) for (i in 1:100) { points(i, 1 / i) } 4.5.1 next and break Sometimes you might not want to execute the commands for every element in the vector use the next command to skip (you can also use the break) some.odds = NULL for (i in 1:200) { if (i %% 2 == 0) { next } some.odds = c(some.odds, i) } some.odds ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 ## [19] 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 ## [37] 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 ## [55] 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143 ## [73] 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 ## [91] 181 183 185 187 189 191 193 195 197 199 Technically, you don’t have to be so formal. But the indenting and braces are there for the protection of your future self. for (i in 1:10) print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 4.6 Functions 4.6.1 The basics Use the ‘function’ command and assign it to an object If you need, specify the expected inputs Do some stuff Return something (and only one thing) to the global environment. my.function = function(x) { do stuff here return(output) } Here’s an example: countThrees = function(vector) { threes &lt;- 0 for(i in vector) { if(i == 3) { threes &lt;- threes + 1 } } return(threes) } v &lt;- c(1, 2, 3, 4, 3, 3) countThrees(v) ## [1] 3 What would happen if we passed in one number instead of a vector? countThrees(2) ## [1] 0 countThrees(3) ## [1] 1 Or a matrix? m &lt;- matrix(1:24, 4, 6) countThrees(m) ## [1] 1 If you want to return multiple values in R, you must put them in a vector or list and return the data structure instead. Remember that a list is essentially a vector that can contain different data types. Sometimes a function will return a value, but other times it will just execute a command like print or plot. 4.7 Setting defaults You can set default values for some of your arguments or all of them gaga.equation = function(num.rah=2, num.ah=3, num.ga=2, num.la=2, num.oo=1) { rahs = paste(rep(&quot;RAH&quot;, num.rah), collapse=&quot;, &quot;) ahs = paste(rep(&quot;AH&quot;, num.ah), collapse=&quot;, &quot;) gas = paste(rep(&quot;GA&quot;, num.ga), collapse=&quot;, &quot;) oo = paste(rep(&quot;OO&quot;, num.oo), collapse=&quot;, &quot;) las = paste(rep(&quot;LA&quot;, num.la), collapse=&quot;, &quot;) paste(rahs, &quot;,&quot;, ahs, &quot;! ROMA, ROMAMA!&quot;, gas, &quot;,&quot;, oo, las) } gaga.equation() ## [1] &quot;RAH, RAH , AH, AH, AH ! ROMA, ROMAMA! GA, GA , OO LA, LA&quot; gaga.equation(num.rah=5) ## [1] &quot;RAH, RAH, RAH, RAH, RAH , AH, AH, AH ! ROMA, ROMAMA! GA, GA , OO LA, LA&quot; If an argument (sometimes called a parameter) does not have a default value, it must be specified when the function is called. 4.8 Scope In the example above, if we tried to print rahs outside of the function, we would get an error. The variable rahs doesn’t exist in the global environment. print(rahs) What happens in the function, stays in the function Remember that for loop variables can be accessed after the loop. for(i in 1:4) { print(i+2) } ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 print(i) ## [1] 4 Note that i equals 4 (its last loop value) after the loop is finished. This is different from functions because the only way to retain access to a local variable that was created in the function is to return it. a &lt;- 10 outer_func &lt;- function() { a &lt;- 20 inner_func &lt;- function() { a &lt;- 30 print(a) } inner_func() print(a) } outer_func() ## [1] 30 ## [1] 20 a ## [1] 10 If you try to run inner_func(), it will say “Error in inner_func() : could not find function”inner_func\"\" because that function is actually a local object inside the function outer_func. That means that outer_func is the only place that can use inner_func. Scope kind of works like a bunch of one way mirrors. If I write a function, it can access all global variables and local (to the function) variables, but the global environment can only access global variables. In the above code example, inner_func can access all of its variables, all of outer_func’s variables, and the global environment variables as well. 4.8.1 Advanced scope topics In R, there’s a superassignment operator which is &lt;&lt;- This assigns the variable to one environment up from its current location. Check out these examples and try to follow along with the environments. This example will replace the global variable a (which used to store 10) with 20 from the outer_func code. Printing a at the end of the script will print 20 this time. a &lt;- 10 outer_func &lt;- function() { a &lt;&lt;- 20 inner_func &lt;- function() { a &lt;- 30 print(a) } inner_func() print(a) } outer_func() ## [1] 30 ## [1] 20 a ## [1] 20 This example will replace a from the outer_func environment with the value 30 so when outer_func prints a, it will now contain 30. a &lt;- 10 outer_func &lt;- function() { a &lt;- 20 inner_func &lt;- function() { a &lt;&lt;- 30 print(a) } inner_func() print(a) } outer_func() ## [1] 30 ## [1] 30 a ## [1] 10 4.9 Debugging traceback will help you identify the function that is failing debug, debugonce will go through a function one line at a time browser This let’s you work within the function environment starting at a specified point Here’s an example to help us practice our debugging skills: webData&lt;-url(&quot;http://pages.wustl.edu/montgomery/incumbents2.txt&quot;) OOS &lt;- read.table(webData) summary(OOS) ## x year congress chalspend ## Min. : 1 Min. :1956 Min. : 84.00 Min. : 8.517 ## 1st Qu.:1672 1st Qu.:1968 1st Qu.: 90.00 1st Qu.: 9.315 ## Median :3347 Median :1978 Median : 95.00 Median :10.998 ## Mean :3348 Mean :1977 Mean : 94.42 Mean :10.880 ## 3rd Qu.:5024 3rd Qu.:1988 3rd Qu.:100.00 3rd Qu.:12.366 ## Max. :6695 Max. :1996 Max. :104.00 Max. :15.039 ## NA&#39;s :3380 ## incspend difflog presvote voteshare ## Min. : 8.586 Min. :-3.060 Min. :0.06565 Min. :0.3476 ## 1st Qu.:12.304 1st Qu.: 0.686 1st Qu.:0.46894 1st Qu.:0.5740 ## Median :12.839 Median : 1.651 Median :0.55519 Median :0.6450 ## Mean :12.759 Mean : 1.858 Mean :0.55335 Mean :0.6470 ## 3rd Qu.:13.266 3rd Qu.: 3.025 3rd Qu.:0.63425 3rd Qu.:0.7141 ## Max. :15.422 Max. : 5.856 Max. :0.96061 Max. :0.9997 ## NA&#39;s :3374 NA&#39;s :3436 NA&#39;s :125 ## inparty incparty seniority midterm ## Min. :0.0000 Min. :0.000 Min. : 1.000 Min. :0.0000 ## 1st Qu.:0.0000 1st Qu.:0.000 1st Qu.: 2.000 1st Qu.:0.0000 ## Median :0.0000 Median :1.000 Median : 4.000 Median :0.0000 ## Mean :0.4942 Mean :0.563 Mean : 4.949 Mean :0.2327 ## 3rd Qu.:1.0000 3rd Qu.:1.000 3rd Qu.: 7.000 3rd Qu.:0.0000 ## Max. :1.0000 Max. :1.000 Max. :26.000 Max. :1.0000 ## ## chalquality south population urban ## Min. :0.0000 Min. :0.0000 Min. :11.98 Min. : 5.956 ## 1st Qu.:0.0000 1st Qu.:0.0000 1st Qu.:12.92 1st Qu.:12.325 ## Median :0.0000 Median :0.0000 Median :13.06 Median :12.728 ## Mean :0.2348 Mean :0.2378 Mean :13.04 Mean :12.612 ## 3rd Qu.:0.0000 3rd Qu.:0.0000 3rd Qu.:13.16 3rd Qu.:13.006 ## Max. :1.0000 Max. :1.0000 Max. :17.08 Max. :16.481 ## NA&#39;s :5 NA&#39;s :2 NA&#39;s :2 ## age65 milpop unemployed incspend2 ## Min. : 8.164 Min. : 3.045 Min. : 7.425 Min. : 5355 ## 1st Qu.:10.452 1st Qu.: 5.517 1st Qu.: 8.816 1st Qu.: 220620 ## Median :10.760 Median : 6.246 Median : 9.142 Median : 376741 ## Mean :10.819 Mean : 6.777 Mean : 9.170 Mean : 450124 ## 3rd Qu.:11.215 3rd Qu.: 8.077 3rd Qu.: 9.544 3rd Qu.: 577283 ## Max. :14.552 Max. :12.691 Max. :13.147 Max. :4987593 ## NA&#39;s :2 NA&#39;s :2 NA&#39;s :2 NA&#39;s :3374 boxplot(voteshare~inparty, data=OOS[OOS$year==1956,]) plot(voteshare~inparty, data=OOS[OOS$year==1956,]) Running a regression by year: Do you see a pattern? output.vector&lt;-NULL for (i in unique(OOS$year)){ output.vector[which(unique(OOS$year) == i)]&lt;- lm(voteshare ~ inparty, data=OOS[OOS$year == i,])$coefficients[2] } plot(unique(OOS$year), output.vector, type=&quot;l&quot;, ylab=&quot;Coefficient (President&#39;s party)&quot;, xlab=&quot;Year&quot;) abline(h=0, lty=3) Now we might think – there is a more general case where I want to get a bunch of seperate regression estimates on defined subsets of the data by.var.lm&lt;-function(by.var, formula, data, coef.num){ output.vector&lt;-NULL for (i in unique(by.var)){ output.vector[which(unique(by.var) == i)]&lt;- lm(formula, data=data[by.var == i,])$coefficients[coef.num] } return(output.vector) } plot(by.var.lm(year, voteshare~inparty, OOS, 2), type=&quot;l&quot;) This is not working, what to do? As a first step, figure out where it’s broken using traceback traceback(by.var.lm(year, voteshare~inparty, OOS, 2)) A second thing to try is to use debug debug(by.var.lm) A second thing to try is to put a broswer function into the function itself browser() Another thing to try is just put in some various print commands by.var.lm&lt;-function(by.var, formula, data, coef.num){ output.vector&lt;-NULL; print(&quot;one&quot;) for (i in unique(by.var)){ print(i) # I can see where I get to in the loop output.vector[which(unique(by.var) == i)]&lt;- lm(formula, data=data[by.var == i,])$coefficients[coef.num] } print(&#39;got out of loop&#39;) return(output.vector) } plot(by.var.lm(year, voteshare~inparty, OOS, 2), type=&quot;l&quot;) So now I have a function that works, can I use it again? website&lt;-url(&quot;http://pages.wustl.edu/montgomery/titanic&quot;) titanic&lt;-read.delim(website) table(titanic$Gender) table(titanic$Class) Make this work by.var.lm(Class, (as.numeric(Survived)-1) ~ Gender, titanic, 2) 4.10 Benchmarking and code improvements x &lt;- runif(500) system.time(sqrt(x)) ## user system elapsed ## 0 0 0 The goal is to see how long a function takes to evaluate Much better: microbenchmark library(microbenchmark) microbenchmark(sqrt(x)) # evaluates 100 times per default ## Unit: microseconds ## expr min lq mean median uq max neval ## sqrt(x) 3.6 3.7 3.978 3.8 4.1 7.6 100 microbenchmark(sqrt(x), times=1000) ## Unit: microseconds ## expr min lq mean median uq max neval ## sqrt(x) 3.5 3.6 3.9671 3.7 3.8 14.2 1000 Now we can compare different functions microbenchmark(sqrt(x), x^0.5, times=1000) ## Unit: microseconds ## expr min lq mean median uq max neval ## sqrt(x) 3.5 4.3 8.9066 6.80 8.9 1555.0 1000 ## x^0.5 26.6 28.4 38.2953 36.55 46.3 409.5 1000 microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2), times=1000) ## Unit: microseconds ## expr min lq mean median uq max neval ## sqrt(x) 3.5 4.80 7.6467 6.6 8.10 453.0 1000 ## x^0.5 26.5 33.10 43.9303 45.8 47.20 447.0 1000 ## x^(1/2) 26.8 32.95 44.2249 46.3 47.85 495.5 1000 ## exp(log(x)/2) 62.1 72.45 84.0047 76.7 104.80 340.1 1000 And also completely different functions microbenchmark(sqrt(x), x^4-3*x) ## Unit: microseconds ## expr min lq mean median uq max neval ## sqrt(x) 3.5 3.7 4.512 3.95 4.60 11.4 100 ## x^4 - 3 * x 33.6 34.5 38.312 35.20 38.95 55.1 100 For ease of interpretation, if a microbenchmark takes - 1 millisecond, then 1,000 calls take a second - 1 microsecond, then 1,000,000 calls take a second - 1 nanosecond, then 1,000,000,000 calls take a second Or use unit=eps for evaluations per second microbenchmark(sqrt(x), x^0.5, x^(1/2), exp(log(x)/2), unit=&quot;eps&quot;) ## Unit: evaluations per second ## expr min lq mean median uq max ## sqrt(x) 85470.085 147058.824 151146.152 156250.000 156250.000 161290.323 ## x^0.5 10822.511 21413.276 21353.375 21645.022 21739.130 21929.825 ## x^(1/2) 13888.889 21186.441 21137.264 21367.521 21505.376 21691.974 ## exp(log(x)/2) 7178.751 9276.438 9240.608 9319.664 9345.794 9380.863 ## neval ## 100 ## 100 ## 100 ## 100 Evaluating every function takes time Evaluating () or {} takes time Even specifying useless arguments in functions takes time! f0 &lt;- function() NULL f1 &lt;- function(a=1) NULL f2 &lt;- function(a=1, b=2) NULL f3 &lt;- function(a=1, b=2, c=3) NULL f4 &lt;- function(a=1, b=2, c=3, d=4) NULL f5 &lt;- function(a=1, b=2, c=3, d=4, e=5) NULL microbenchmark(f0(), f1(), f2(), f3(), f4(), f5(), times=10000) ## Unit: nanoseconds ## expr min lq mean median uq max neval ## f0() 200 300 485.70 400 500 575600 10000 ## f1() 200 300 546.01 500 500 591700 10000 ## f2() 200 400 648.67 500 600 984600 10000 ## f3() 300 400 684.39 600 600 737000 10000 ## f4() 300 500 742.37 600 700 701700 10000 ## f5() 300 500 804.25 700 800 743800 10000 Extracting one element of a data frame microbenchmark( &quot;[32, 11]&quot; = mtcars[32,11], &quot;$carb[32]&quot; = mtcars$carb[32], &quot;[[c(11, 32)]]&quot; = mtcars[[c(11,32)]], &quot;[[11]][32]&quot; = mtcars[[11]][32], &quot;.subset2&quot; = .subset2(mtcars,11)[32]) ## Unit: nanoseconds ## expr min lq mean median uq max neval ## [32, 11] 12700 13300 14339 13700 14200 44800 100 ## $carb[32] 6400 7000 7787 7400 7800 38400 100 ## [[c(11, 32)]] 5700 6100 6571 6300 6700 21300 100 ## [[11]][32] 5400 5750 6118 5950 6300 10900 100 ## .subset2 300 400 624 500 500 10700 100 4.10.1 Vectorizing The key idea behind vectorizing your code is to think about entire vectors instead of thinking about their components. Using apply and co instead of for loops is a start, but does not really solve this issue. Truly vectorized functions will make use of code written in C instead of R. Loops in C are much faster because they have much less overhead. Addition on each element of a data frame rm(list=ls()) m=5 n=5 matrix1 &lt;- replicate(m, rnorm(n)) # create matrix matdf &lt;- matdf1 &lt;- data.frame(matrix1) matdf ## X1 X2 X3 X4 X5 ## 1 1.401463 -0.08538131 0.7254809 1.3932078 0.2971129 ## 2 1.204480 -0.35742433 1.1605121 -1.5985663 -0.7159475 ## 3 -1.218300 -0.04982843 0.9356040 -0.5352060 -0.3760388 ## 4 1.235914 0.38822090 -2.0086046 0.3052788 -0.4474556 ## 5 -1.430694 1.74663026 -1.1960035 0.1319573 -0.3835745 for (i in 1:m) { for (j in 1:n) { matdf1[i,j] &lt;- matdf1[i,j] + 1.87*cos(.25)*pi # addition } } matdf1 ## X1 X2 X3 X4 X5 ## 1 7.093608 5.606764 6.417627 7.085353 5.989259 ## 2 6.896625 5.334721 6.852658 4.093579 4.976198 ## 3 4.473845 5.642317 6.627750 5.156940 5.316107 ## 4 6.928060 6.080367 3.683541 5.997424 5.244690 ## 5 4.261451 7.438776 4.496142 5.824103 5.308571 matdf2&lt;-data.frame(matrix1) matdf2 &lt;- matdf2 + 1.87*cos(.25)*pi matdf2 ## X1 X2 X3 X4 X5 ## 1 7.093608 5.606764 6.417627 7.085353 5.989259 ## 2 6.896625 5.334721 6.852658 4.093579 4.976198 ## 3 4.473845 5.642317 6.627750 5.156940 5.316107 ## 4 6.928060 6.080367 3.683541 5.997424 5.244690 ## 5 4.261451 7.438776 4.496142 5.824103 5.308571 microbenchmark( &quot;loop&quot; = for (i in 1:m) { for (j in 1:n) { matdf[i,j] &lt;- matdf[i,j] + 1.87*cos(.25)*pi } }, &quot;vectorized&quot; = matdf &lt;- matdf + 1.87*cos(.25)*pi ) ## Unit: microseconds ## expr min lq mean median uq max neval ## loop 5618.2 5878.4 7104.939 6108.05 8144.45 13120.2 100 ## vectorized 413.8 468.0 581.052 513.90 599.35 1553.6 100 mat1 &lt;- matrix(abs(rnorm(2500))+pi, ncol=50) apply(mat1, 1, function(x) sum(x)) ## [1] 196.7358 199.5213 192.7305 203.5306 196.4766 189.4143 203.0960 202.5399 ## [9] 200.0148 193.3242 202.3175 191.5472 195.7860 199.4855 193.1041 192.9694 ## [17] 196.0379 200.6371 201.6698 195.8663 198.5713 201.7909 198.8656 186.7031 ## [25] 198.2399 195.5251 203.9680 197.0923 191.0145 200.4627 200.7971 190.8046 ## [33] 192.5875 198.7972 198.1255 191.7137 198.8790 193.1047 201.6692 196.7622 ## [41] 200.8379 195.5919 204.1649 186.5547 194.9395 202.6542 196.9513 198.0440 ## [49] 193.4437 193.4196 rowSums(mat1) ## [1] 196.7358 199.5213 192.7305 203.5306 196.4766 189.4143 203.0960 202.5399 ## [9] 200.0148 193.3242 202.3175 191.5472 195.7860 199.4855 193.1041 192.9694 ## [17] 196.0379 200.6371 201.6698 195.8663 198.5713 201.7909 198.8656 186.7031 ## [25] 198.2399 195.5251 203.9680 197.0923 191.0145 200.4627 200.7971 190.8046 ## [33] 192.5875 198.7972 198.1255 191.7137 198.8790 193.1047 201.6692 196.7622 ## [41] 200.8379 195.5919 204.1649 186.5547 194.9395 202.6542 196.9513 198.0440 ## [49] 193.4437 193.4196 microbenchmark(apply(mat1, 1, function(x) sum(x)), rowSums(mat1)) ## Unit: microseconds ## expr min lq mean median uq max ## apply(mat1, 1, function(x) sum(x)) 120.3 123.75 140.469 126.05 129.25 1376.1 ## rowSums(mat1) 12.4 12.70 13.600 13.70 14.10 21.3 ## neval ## 100 ## 100 Even for basic tasks, think about the actual calculations you perform mat2 &lt;- matrix(sample(1:7, 90000, replace=T), ncol=300) mat3 &lt;- matrix(sample(2:6, 90000, replace=T), ncol=300) ys &lt;- sample(3:5, 300, replace=T) all.equal(mat2 %*% mat3 %*% ys , mat2 %*% (mat3 %*% ys)) ## [1] TRUE microbenchmark(mat2 %*% mat3 %*% ys, mat2 %*% (mat3 %*% ys)) ## Unit: microseconds ## expr min lq mean median uq max ## mat2 %*% mat3 %*% ys 11617.4 12904.7 15992.690 14132.25 17076.5 37768.7 ## mat2 %*% (mat3 %*% ys) 483.1 597.5 965.834 794.70 877.8 10892.2 ## neval ## 100 ## 100 Why? Think through the dimensionality 4.10.2 Paste/collapse and copies random_states &lt;- function() { paste(sample(state.name,10,replace =TRUE),collapse =&quot;&quot;) } states10 &lt;- replicate(10, random_states()) states10 ## [1] &quot;KentuckyColoradoLouisianaIowaNew YorkHawaiiGeorgiaConnecticutSouth DakotaGeorgia&quot; ## [2] &quot;MarylandIowaOhioWest VirginiaNew HampshireAlabamaWyomingKansasFloridaIowa&quot; ## [3] &quot;North DakotaCaliforniaOhioVermontMichiganWisconsinWashingtonNebraskaSouth DakotaIowa&quot; ## [4] &quot;West VirginiaTexasIllinoisDelawareAlaskaWyomingMichiganMontanaArizonaVermont&quot; ## [5] &quot;ColoradoAlabamaWashingtonMassachusettsNew MexicoNew JerseyKansasVirginiaMontanaOklahoma&quot; ## [6] &quot;ColoradoMarylandMaineSouth CarolinaNorth CarolinaCaliforniaFloridaGeorgiaWyomingHawaii&quot; ## [7] &quot;North CarolinaTexasWyomingAlaskaMainePennsylvaniaNew MexicoRhode IslandPennsylvaniaNew Jersey&quot; ## [8] &quot;MinnesotaGeorgiaNew MexicoWisconsinRhode IslandWest VirginiaHawaiiNebraskaMarylandNew Jersey&quot; ## [9] &quot;New HampshireIdahoNew JerseyNew HampshireMississippiAlaskaWisconsinNorth DakotaWashingtonArizona&quot; ## [10] &quot;MissouriMarylandMaineMichiganMarylandMinnesotaTexasMinnesotaCaliforniaNebraska&quot; states100 &lt;- replicate(100, random_states()) collapse &lt;- function(states) { out &lt;- &quot;&quot; for (x in states) { out &lt;- paste0(out, x) # same as paste(..., sep=&quot;&quot;, collapse) } out } microbenchmark( &quot;loop10&quot; = collapse(states10), &quot;vec10&quot; = paste(states10, collapse =&quot;&quot;), &quot;loop100&quot; = collapse(states100), &quot;vec100&quot; = paste(states100, collapse =&quot;&quot;) ) ## Unit: microseconds ## expr min lq mean median uq max neval ## loop10 29.8 33.15 97.016 52.05 59.85 4769.4 100 ## vec10 8.7 11.55 15.111 15.60 17.40 45.0 100 ## loop100 1425.4 1772.45 2263.980 2474.00 2774.35 3340.8 100 ## vec100 75.8 86.30 125.827 134.30 152.30 250.7 100 PRO TIP: Allocate memory and fill, don’t append to the end Here, we are not only getting around using the loop, but also avoiding copies. Whenever you append(), cbind(), rbind(), or paste() to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home. If you’re repeating this many times, like in a for loop, this can be quite computationally expensive. Instead, allocate an object of the largest size you think you’ll need, and fill it up as you go. Fun fact: in Java (another programming language), arrays function the same way as vectors in R. Java has a data structure called an ArrayList, which allows users to add and remove as needed. When it gets full, it doubles the size/capacity of the underlying array and copies everything over. When an element is removed, it doesn’t decrease the size of the underlying array because copying things over and allocating new space is very inefficient. "],
["version-control.html", "5 Version Control 5.1 Why version control? 5.2 Setup 5.3 Workflow 5.4 Branches 5.5 Forking 5.6 Reverting 5.7 Version Control in RStudio", " 5 Version Control 5.1 Why version control? Have you ever … (Source: Stack overflow) - Made a change to code, realised it was a mistake and wanted to revert back? - Lost code or had a backup that was too old? - Had to maintain multiple versions of a product? - Wanted to see the difference between two (or more) versions of your code? - Wanted to prove that a particular change broke or fixed a piece of code? - Wanted to review the history of some code? - Wanted to submit a change to someone else’s code? - Wanted to share your code, or let other people work on your code? - Wanted to see how much work is being done, and where, when and by whom? - Wanted to experiment with a new feature without interfering with working code? 5.2 Setup Install Git: http://git-scm.com/book/en/Getting-Started-Installing-Git Sign up for GitHub Install the GUI http://mac.github.com/ http://windows.github.com/ 5.3 Workflow Every time you work on a group project that is stored in git, you should pull right away, do your work, then commit and push immediately. I recommend doing this workflow every time you make a significant change or start working on something else. It backs up your work so that you can go back to an earlier version in case you mess something up later. 5.3.1 Pull This updates your repository to the newest version so that when other people on your team make changes, you will be able to have the most recently updated version of the code/repository. 5.3.2 Commit This is step 1 of adding your changes to GitHub (push is step 2). Committing your changes requires that you specify which changed files you want to commit as well as a brief commit message summarizing what you changed since the last commit. 5.3.3 Push This is step 2 of adding your changes to GitHub. You can think of committimg as wrapping up a gift that you made and pushing is mailing it to the recipient. They don’t “open” the gift until they Pull and see what you pushed. Pushing uploads all un-pushed commits to GitHub so that you can see them in GitHub desktop as well as your repository online. 5.4 Branches Large software projects use branches to have a production environment that is always working, and other branches for new feature development. Once a feature is ready, the development branch can be merged with the production branch (typically master). You’ll have to manually choose which version of each file to keep. 5.5 Forking If you see someone’s repository and want to copy it and make your own changes without affecting their repository (and potentially without them even knowing), you can “fork” the repository. This gives you your own copy of it to mess with as you please. 5.6 Reverting If you make a mistake and commit and push it (or your team member does), you can revert to a prior commit. This is why it’s super useful to commit and push regulary!!! You can revert from any commit which will set your current repository state back to exactly what it looked like at that exact moment in time. 5.7 Version Control in RStudio If you have a GitHub repository that you want to open in RStudio, here are the steps: Open RStudio File -&gt; New Project -&gt; Version Control -&gt; Git Paste your repository URL and change where you want it to clone the repository on your local machine All of the files in the repository are now found in the “files” tab in RStudio. To pull, open the “git” tab and click the blue down arrow. To commit, select the check boxes next to the changed files you wish to commit and click the “commit” button. To push, click the green up arrow. Note: if you want to switch branches, you can click on “master” in the git tab. To switch projects, click on the cube icon in the top right corner. This gives you options for creating a new project, viewing recent projects, and opening existing projects. For more info, check out this link "],
["data-visualization-in-r.html", "6 Data Visualization in R 6.1 Intro to ggplot2 6.2 More geom options", " 6 Data Visualization in R 6.1 Intro to ggplot2 ggplot2 is a powerful way to build both simple and complex data visualizations Takes care of a lot of the stupid aspects of plot building Provides a language for layering visual elements Has been extended in dozens of ways to handle all kinds of data Integrates easily into the rest of the tidyverse 6.1.1 Example Data comes from 538.com library(ggplot2) primaryPolls&lt;-read.csv(&#39;https://jmontgomery.github.io/PDS/Datasets/president_primary_polls_feb2020.csv&#39;, stringsAsFactors = F) primaryPolls$start_date&lt;-as.Date(primaryPolls$start_date, &quot;%m/%d/%Y&quot;) primaryPolls&lt;-primaryPolls[primaryPolls$state==&quot;New Hampshire&quot;,] primaryPolls&lt;-primaryPolls[primaryPolls$candidate_name%in%c(&quot;Amy Klobuchar&quot;, &quot;Bernard Sanders&quot;, &quot;Elizabeth Warren&quot;, &quot;Joseph R. Biden Jr.&quot;, &quot;Michael Bloomberg&quot;, &quot;Pete Buttigieg&quot;),] ggplot(data=primaryPolls)+ geom_point(mapping = aes(x=start_date, y=pct)) The first line is always ggplot, which sets up the basic object that we will layer onto Then we use the + to add layers. In this case geom_points. THe + must be at the end of each line - not the beginning. Any geom layer requires a mapping argument, which itself comes with an aes argument explaining what goes on the x and y coordinates. Conveniently, the dataset only needs to be specified once. 6.1.2 Aesthetics The aes stands for aesthetics. The nice part is we can easily make this more comlex And ggplot has pretty good defaults to handle things like color choices, legends, etc. ggplot(data=primaryPolls)+ geom_point(mapping = aes(x=start_date, y=pct, color= candidate_name)) Note that ggplot automatically chose a unique color. It can do the same with shapes, point size, and transparency (alpha). alpha = 1 is completely opaque, alpha = 0.2 would be almost entirely see-through You can also set aesthetic characteristics manually (as I do with alpha here) Note that shapes only works by default with 6 categories ggplot(data=primaryPolls)+ geom_point(mapping = aes(x=start_date, y=pct, shape= candidate_name, color=candidate_name), alpha=.8) 6.1.3 Facets Perhaps most helpfully we can parse the data by features using a simple line ggplot will then arrange everything else so it looks pretty OK ggplot(data=primaryPolls)+ geom_point(mapping = aes(x=start_date, y=pct)) + facet_wrap(~ candidate_name, nrow=4) You can also make a grid of plots, one dimension has each population level and the other has the candidate names ggplot(data=primaryPolls)+ geom_point(mapping = aes(x=start_date, y=pct)) + facet_wrap(population ~ candidate_name, nrow=2) 6.2 More geom options ggplot(data=primaryPolls)+ geom_smooth(mapping = aes(x=start_date, y=pct, color=candidate_name)) + facet_wrap(~ candidate_name, nrow=2) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data=primaryPolls)+ geom_smooth(mapping = aes(x=start_date, y=pct, color=candidate_name)) + geom_point(mapping = aes(x=start_date, y=pct, color=candidate_name), alpha=.4) + facet_wrap(~ candidate_name, nrow=2) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data=primaryPolls)+ geom_smooth(mapping = aes(x=start_date, y=pct, color=candidate_name, linetype=candidate_name)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ANd maybe we don’t want a legend? ggplot(data=primaryPolls)+ geom_smooth(mapping = aes(x=start_date, y=pct, group=candidate_name)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data=primaryPolls)+ geom_smooth(mapping = aes(x=start_date, y=pct, color=candidate_name), show.legend=FALSE) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; We can combine multiple geom objects ggplot(data=primaryPolls)+ geom_smooth(mapping = aes(x=start_date, y=pct, color=candidate_name))+ geom_point(mapping = aes(x=start_date, y=pct, color=candidate_name), alpha=.4) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; But we can also do this in a way easier to change (less copying and pasting) ggplot(data=primaryPolls, mapping=aes(x=start_date, y=pct, color=candidate_name))+ geom_smooth()+ geom_point(alpha=.4) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; And you can add specifics elments to a sub-layer ggplot(data=primaryPolls, mapping=aes(x=start_date, y=pct, color=candidate_name))+ geom_smooth()+ geom_point(aes(size=sample_size), alpha=.4) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; A lot of other options you are interested require knowing the right geom function ggplot(data=primaryPolls, mapping=aes(x=fte_grade))+ geom_bar() This is also the same as counting the number of obserervations in each bin ggplot(data=primaryPolls, mapping=aes(x=fte_grade))+ stat_count() This is also the same as counting the number of obserervations in each bin ggplot(data=primaryPolls, mapping=aes(x=candidate_name, y=pct))+ stat_summary( fun.ymin=min, fun.ymax=max, fun.y=median ) You can also flip the coordinate system fairly quickly ggplot(data=primaryPolls, mapping=aes(x=candidate_name, y=pct))+ geom_boxplot() ggplot(data=primaryPolls, mapping=aes(x=candidate_name, y=pct))+ geom_boxplot() + coord_flip() "]
]
